{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"pyobsidian","text":""},{"location":"#overview","title":"Overview","text":"<p><code>pyobsidian</code> is a python library for working with Obsidian vaults. It's allows you to find and manipulate any note in your Obsidian vault.</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install pyobsidian\n</code></pre>"},{"location":"#usage","title":"Usage","text":"<p>A common workflow used in this library is to define a vault, create a sequence of steps, and execute it to manipulate notes. This workflow can be seen below. This workflow can see bellow:</p> <p> </p> <p>This can be translated to code in a very simple way. <pre><code>&gt;&gt;&gt; from pyobsidian.vault import Vault\n&gt;&gt;&gt; from pyobsidian.adder_op import OpMkHeader\n&gt;&gt;&gt; vault = Vault('your/obsidian/vault/path')\n&gt;&gt;&gt; new_vault = (\n...    vault\n...    .find_by('folder', 'some_folder')\n...    .find_by('tag', 'some_tag')\n...    .add('content', '# Some header', OpMkHeader('|&gt;{1}h1'))\n...    .execute()\n...)\n&gt;&gt;&gt; print(vault)\nVault(\n    path='your/obsidian/vault/path',\n    notes=[],\n    filter=Filter(),\n    adder=Adder()\n)\n&gt;&gt;&gt; print(new_vault)\nVault(\n    path='your/obsidian/vault/path',\n    notes=[Note(path='your/obsidian/vault/path/.../note.md')],\n    filter=Filter(\n        [\n            FilterField(Field(key='folder', value='some_folder', occurrence='file'), mode = 'and'),\n            FilterField(Field(key='tag', value='some_tag', occurrence='file'), mode = 'and')\n        ]\n    ),\n    adder=Adder(\n        [\n            AdderField(key='content', value='# Some header', where=OpMkHeader('&lt;|{1}h1'))\n        ]\n    )\n)\n&gt;&gt;&gt; print(new_vault.notes)\n[Note(path='your/obsidian/vault/path/.../note.md')]\n</code></pre></p>"},{"location":"#getting-help","title":"Getting help","text":"<p>If you encounter a clear bug, please file an issue with a minimal reproducible example on GitHub.</p>"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"changelog/#020-2024-06-04","title":"[0.2.0] - 2024-06-04","text":""},{"location":"changelog/#added","title":"Added","text":"<ul> <li>Helpers functions</li> <li>Utilities for working with markdown to enable parsing and obtaining headers</li> <li><code>AdderWhere</code> to enable additions in specific locations of notes</li> <li><code>Op</code> to enable extensions in content additions, allowing users to define new forms of addition</li> <li><code>Formatter</code> for formatting the content to be added</li> <li><code>Adder</code> provisioned by <code>add</code> in <code>Vault</code>, allowing you to add content to filtered notes</li> <li>methods <code>read</code> and <code>write</code> in <code>Note</code> class</li> </ul>"},{"location":"changelog/#removed","title":"Removed","text":"<ul> <li><code>NoterReader</code> was removed, passing method to<code>Note</code></li> </ul>"},{"location":"changelog/#011-2024-05-30","title":"[0.1.1] - 2024-05-30","text":""},{"location":"changelog/#removed_1","title":"Removed","text":"<ul> <li>Development packages from the build</li> </ul>"},{"location":"changelog/#010-2024-05-30","title":"[0.1.0] - 2024-05-30","text":""},{"location":"changelog/#added_1","title":"Added","text":"<ul> <li><code>Note</code> class to represent a note in Obsidian vault</li> <li><code>Filter</code> class to represent an filter</li> <li><code>SearchBy</code> class to represent search strategy</li> <li><code>Vault</code> class to represent an Obsidian vault</li> </ul>"},{"location":"license/","title":"License","text":"<p>MIT License</p> <p>Copyright (c) 2024 Matheus S. Rodrigues</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"articles/filter_mode/","title":"Understanding filter <code>mode</code>","text":"<p>One important argument used in filters is <code>mode</code>. In this section, we'll explore how it works.</p>"},{"location":"articles/filter_mode/#and-or-and","title":"And, or, and","text":"<p>Let's start example with a sequence of mode <code>and</code>, <code>or</code>, and <code>and</code>. An example of how this sequence could be obtained is shown below.</p> <pre><code>&gt;&gt;&gt; from pyobsidian.vault import Vault\n&gt;&gt;&gt; vault = Vault('your/obsidian/vault/path')\n&gt;&gt;&gt; new_vault = (\n...     vault\n...     .find_by('folder', 'x', 'and')\n...     .find_by('tag', 'y', 'or')\n...     .find_by('related_note', 'z', 'and')\n...     .execute()\n... )\n</code></pre> <p>Let's consider that the analyzed vault has 4 notes. The image below illustrates this scenario.</p> <p></p> <ul> <li>Filters with [A] represent filters that apply the \"and\" mode and [O] filters with \"or\" mode</li> <li>All notes with [ X ] represent notes that meet the filter criteria. Notes with [  ] do not meet the criteria</li> <li>Notes with [ ? ] are notes that the filter cannot yet evaluate because previous steps are necessary</li> </ul> <p>In this situation, note 1 meets the criteria of filter 1 and notes 1 and 4 meet the criteria of filter 2. Since filter 3 is applied after these filters, it does not yet know which notes will arrive to be evaluated. Therefore, it is not possible to know which notes meet the requirements of filter 3.</p> <p>After applying filters 1 and 2, the scenario below is obtained.</p> <p></p> <p>Due to the conditions of filters 1 and 2, only notes 1 and 4 can be seen by filter 3. And only note 4 meets the criteria of filter 3. As the last condition is an \"and\", only notes that meet the final application will remain. In this case, only grade 4 meets all these requirements. This way, the final result is a grade 4.</p> <p></p>"},{"location":"articles/filter_mode/#and-and-or","title":"And, and, or","text":"<p>Now we will try to approach this problem with another sequence of filters: and, and, or.</p> <p></p> <p>In this situation, only note 1 meets the criteria of filter 1, so only this note can be seen by filter 3 since an \"and\" is applied with it. However, note 1 does not meet the criteria of filter 3. As a result, the final result of these steps does not return any note. However, it is important to highlight that filter 2, as it is applied as \"or\", can see all the notes in the vault in question.</p> <p></p> <p>With this scenario, because the mode is \"or\", all notes that meet the criteria will be filtered. In this case, only the notes filtered by filter 2 will remain.</p> <p></p>"},{"location":"articles/filter_mode/#behaviors","title":"Behaviors","text":"<p>With these examples it is possible to note important characteristics when applying these modes:</p> <ul> <li>Filters applied with 'and' can only see the notes applied after the previous steps.</li> <li>Filters applied with 'or' can see all notes in the current vault.</li> </ul> <p>This behavior of 'or' can be changed by executing <code>execute</code> before applying all steps. For example: <pre><code>&gt;&gt;&gt; from pyobsidian.vault import Vault\n&gt;&gt;&gt; vault = Vault('your/obsidian/vault/path')\n&gt;&gt;&gt; new_vault = (\n...     vault\n...     .find_by('folder', 'x', 'and')\n...     .execute()\n...     .find_by('tag', 'y', 'or')\n...     .find_by('related_note', 'z', 'and')\n...     .execute()\n... )\n</code></pre></p> <p>The execute performs the searches, so the 'or' method will only see the notes after the 'folder' filter. With this manipulation it is possible to create complex filters that meet different criteria.</p>"},{"location":"articles/new_search_strategy/","title":"Creating new search strategy","text":"<p>Sometimes, you will need to customize search strategies. <code>pyobsidian</code> provides a way to do that.</p>"},{"location":"articles/new_search_strategy/#the-problem","title":"The problem","text":"<p>Suppose, for some reason, you need to search for notes that filename contains a pattern. There is no such method by default. So, you need to create a new search strategy.</p>"},{"location":"articles/new_search_strategy/#creating-new-strategy-with-default-implementation","title":"Creating new strategy with default implementation","text":"<p>All strategies follow the same interface: SearchBy. The following methods are defined in this interface:</p> <ul> <li><code>search(notes: list[Note], field: Field)</code></li> <li><code>condition(note: Note, field: Field)</code></li> <li><code>__search(notes: list[Note], field: Field)</code></li> <li><code>is_valid_value(value: FieldValue)</code></li> <li><code>convert_field_value_to_list(value: FieldValue)</code></li> </ul> <p>However, a template with default implementation is provided (<code>SearchByDefault</code>). This class implements the methods in a way that they will generally be used. We can use it as a template to create new search strategies!</p> <p>To do this, you will need to create a new class that inherits from <code>SearchByDefault</code> and implements <code>condition</code> method. For this hypothetical scenario, we would have:</p> <pre><code>&gt;&gt;&gt; from pyobsidian.searchby import SearchByDefault\n&gt;&gt;&gt; class SearchByFilenameRegex(SearchByDefault):\n...     def condition(self, note: Note, field: Field) -&gt; bool:\n...         attr = getattr(note.properties, 'filename')\n...         return any(re.findall(str(field.value), attr))\n</code></pre> <p>This simple code is enough to create a new search strategy. Now, you can add it to vault search strategies.</p> <pre><code>&gt;&gt;&gt; from pyobsidian.vault import Vault\n&gt;&gt;&gt; vault = Vault('your/obsidian/vault/path')\n&gt;&gt;&gt; vault.add_new_search_strategy(\n...     'filename_regex', \n...     SearchByFilenameRegex\n... )\n&gt;&gt;&gt; new_vault = (\n...     vault\n...     .find_by('filename_regex', 'test')\n...     .execute()\n... )\n&gt;&gt;&gt; notes_with_test_in_filename = new_vault.notes\n</code></pre>"},{"location":"reference/adder/","title":"adder","text":"<p>This module contains the classes that represent adders.</p> <p>Adders are used to add content to Obsidian notes.</p>"},{"location":"reference/adder/#pyobsidian.adder.Adder","title":"<code>Adder(fields: list[AdderField] = [])</code>","text":"<p>Adder class.</p> <p>Parameters:</p> <ul> <li> <code>fields</code>               (<code>list[AdderField]</code>, default:                   <code>[]</code> )           \u2013            <p>The fields of the adder.</p> </li> </ul> Source code in <code>pyobsidian/adder.py</code> <pre><code>def __init__(self: Self, fields: list[AdderField] = []) -&gt; None:\n    self.__fields = fields\n</code></pre>"},{"location":"reference/adder/#pyobsidian.adder.Adder.add_field","title":"<code>add_field(field: AdderField) -&gt; Adder</code>","text":"<p>Add a new adder field to the adder.</p> <p>Parameters:</p> <ul> <li> <code>field</code>               (<code>AdderField</code>)           \u2013            <p>The field to be added.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Adder</code>           \u2013            <p>The new adder.</p> </li> </ul> Source code in <code>pyobsidian/adder.py</code> <pre><code>def add_field(self: Self, field: AdderField) -&gt; Adder:\n    \"\"\"Add a new adder field to the adder.\n\n    Parameters\n    ----------\n    field : AdderField\n        The field to be added.\n\n    Returns\n    -------\n    Adder\n        The new adder.\n    \"\"\"\n    cur_fields = self.fields\n    new_fields = cur_fields + [field]\n    new_adder = Adder(new_fields)\n    return new_adder\n</code></pre>"},{"location":"reference/adder/#pyobsidian.adder.AdderField","title":"<code>AdderField(key: AdderKey, value: AdderValue, where: AdderFieldWhere)</code>  <code>dataclass</code>","text":"<p>Class that represents an adder field.</p>"},{"location":"reference/adder/#pyobsidian.adder.AdderRegistry","title":"<code>AdderRegistry</code>","text":"<p>Adder registry.</p> <p>Consolidates AdderWhere along with its possible formatters. T</p>"},{"location":"reference/adder/#pyobsidian.adder.AdderRegistry.add_formatter","title":"<code>add_formatter(by: str, where: str, formatter: Formatter) -&gt; dict[tuple[str, str], Formatter]</code>  <code>classmethod</code>","text":"<p>Add a new adder formatter to Adder class.</p> <p>Parameters:</p> <ul> <li> <code>by</code>               (<code>str</code>)           \u2013            <p>The key of the formatter.</p> </li> <li> <code>where</code>               (<code>str</code>)           \u2013            <p>The where of the formatter.</p> </li> <li> <code>formatter</code>               (<code>Formatter</code>)           \u2013            <p>The formatter to be added.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[tuple[str, str], Formatter]</code>           \u2013            <p>The updated formatters.</p> </li> </ul> Source code in <code>pyobsidian/adder.py</code> <pre><code>@classmethod\ndef add_formatter(\n    cls: Type, \n    by: str, \n    where: str, \n    formatter: Formatter\n) -&gt; dict[tuple[str, str], Formatter]:\n    \"\"\"Add a new adder formatter to Adder class.\n\n    Parameters\n    ----------\n    by : str\n        The key of the formatter.\n    where : str\n        The where of the formatter.\n    formatter : Formatter\n        The formatter to be added.\n\n    Returns\n    -------\n    dict[tuple[str, str], Formatter]\n        The updated formatters.\n    \"\"\"\n    cls.formatters[(by, where)] = formatter\n    return cls.formatters\n</code></pre>"},{"location":"reference/adder/#pyobsidian.adder.AdderRegistry.add_registry","title":"<code>add_registry(key: str, where: AdderWhere) -&gt; dict[str, AdderWhere]</code>  <code>classmethod</code>","text":"<p>Add a new where to the registry.</p> <p>Parameters:</p> <ul> <li> <code>key</code>               (<code>str</code>)           \u2013            <p>The key of the where.</p> </li> <li> <code>where</code>               (<code>AdderWhere</code>)           \u2013            <p>The where to add.</p> </li> </ul> Source code in <code>pyobsidian/adder.py</code> <pre><code>@classmethod\ndef add_registry(cls: Type, key: str, where: AdderWhere) -&gt; dict[str, AdderWhere]:\n    \"\"\"Add a new where to the registry.\n\n    Parameters\n    ----------\n    key : str\n        The key of the where.\n    where : AdderWhere\n        The where to add.\n    \"\"\"\n    cls.where[key] = where\n    return cls.where\n</code></pre>"},{"location":"reference/adder/#pyobsidian.adder.AdderRegistry.get_formatter","title":"<code>get_formatter(by: str, where: AdderFieldWhere) -&gt; Optional[Formatter]</code>  <code>classmethod</code>","text":"<p>Get the adder formatter.</p> <p>Parameters:</p> <ul> <li> <code>by</code>               (<code>str</code>)           \u2013            <p>The key of the formatter.</p> </li> <li> <code>where</code>               (<code>AdderFieldWhere</code>)           \u2013            <p>The where of the formatter.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Optional[Formatter]</code>           \u2013            <p>The formatter.</p> </li> </ul> Source code in <code>pyobsidian/adder.py</code> <pre><code>@classmethod\ndef get_formatter(\n    cls: Type, \n    by: str, \n    where: AdderFieldWhere\n) -&gt; Optional[Formatter]:\n    \"\"\"Get the adder formatter.\n\n    Parameters\n    ----------\n    by : str\n        The key of the formatter.\n    where : AdderFieldWhere\n        The where of the formatter.\n\n    Returns\n    -------\n    Optional[Formatter]\n        The formatter.\n    \"\"\"\n    if isinstance(where, tuple):\n        return cls.formatters.get((by, where[0]))\n    return cls.formatters.get((by, where))\n</code></pre>"},{"location":"reference/adder/#pyobsidian.adder.AdderRegistry.get_where","title":"<code>get_where(key: str | tuple) -&gt; Optional[AdderWhere]</code>  <code>classmethod</code>","text":"<p>Get the adder where.</p> <p>Parameters:</p> <ul> <li> <code>key</code>               (<code>str</code>)           \u2013            <p>The key of the where.</p> </li> </ul> Source code in <code>pyobsidian/adder.py</code> <pre><code>@classmethod\ndef get_where(cls: Type, key: str | tuple) -&gt; Optional[AdderWhere]:\n    \"\"\"Get the adder where.\n\n    Parameters\n    ----------\n    key : str\n        The key of the where.\n    \"\"\"\n    if isinstance(key, tuple):\n        return cls.where.get(key[0])\n    return cls.where.get(key)\n</code></pre>"},{"location":"reference/adder/#pyobsidian.adder.AdderWhere","title":"<code>AdderWhere</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Interface for adder where.</p>"},{"location":"reference/adder/#pyobsidian.adder.AdderWhere.exec","title":"<code>exec(note: Note, field: AdderField) -&gt; Optional[str]</code>","text":"<p>Execute the adder where.</p> <p>Parameters:</p> <ul> <li> <code>note</code>               (<code>Note</code>)           \u2013            <p>The note to add the content to.</p> </li> <li> <code>field</code>               (<code>AdderField</code>)           \u2013            <p>The field to add the content to.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Optional[str]</code>           \u2013            <p>The content to add to the note.</p> </li> </ul> Source code in <code>pyobsidian/adder.py</code> <pre><code>def exec(\n    self: Self, \n    note: Note,\n    field: AdderField\n) -&gt; Optional[str]:\n    \"\"\"Execute the adder where.\n\n    Parameters\n    ----------\n    note : Note\n        The note to add the content to.\n    field : AdderField\n        The field to add the content to.\n\n    Returns\n    -------\n    Optional[str]\n        The content to add to the note.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/adder/#pyobsidian.adder.AdderWhereInline","title":"<code>AdderWhereInline</code>","text":"<p>               Bases: <code>AdderWhere</code></p> <p>Class that represents an adder where inline.</p>"},{"location":"reference/adder/#pyobsidian.adder.AdderWhereOpMkHeader","title":"<code>AdderWhereOpMkHeader</code>","text":"<p>               Bases: <code>AdderWhere</code></p> <p>Class that represents an adder where op mk header.</p>"},{"location":"reference/adder/#pyobsidian.adder.AdderWhereYaml","title":"<code>AdderWhereYaml</code>","text":"<p>               Bases: <code>AdderWhere</code></p> <p>Class that represents an adder where yaml.</p>"},{"location":"reference/adder_op/","title":"adder_op","text":"<p>This module contains the classes that represent Obsidian adder operators.</p> <p>Operators make it possible to create very specific ways to adding content to notes. They are generally used together with AdderWhere.</p>"},{"location":"reference/adder_op/#pyobsidian.adder_op.Op","title":"<code>Op(operator: str)</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Base class for all adder operators.</p> Source code in <code>pyobsidian/adder_op.py</code> <pre><code>def __init__(self: Self, operator: str):\n    self.__raw_operator = operator\n    self.__operator = self.build_operator(operator)\n</code></pre>"},{"location":"reference/adder_op/#pyobsidian.adder_op.Op.id","title":"<code>id: str</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>The identifier of the operator.</p>"},{"location":"reference/adder_op/#pyobsidian.adder_op.Op.build_operator","title":"<code>build_operator(operator: str) -&gt; Any</code>  <code>abstractmethod</code>","text":"<p>Build the operator.</p> <p>Parameters:</p> <ul> <li> <code>operator</code>               (<code>str</code>)           \u2013            <p>The operator string.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Any</code>           \u2013            <p>The operator.</p> </li> </ul> Source code in <code>pyobsidian/adder_op.py</code> <pre><code>@abstractmethod\ndef build_operator(self: Self, operator: str) -&gt; Any:\n    \"\"\"Build the operator.\n\n    Parameters\n    ----------\n    operator : str\n        The operator string.\n\n    Returns\n    -------\n    Any\n        The operator.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/adder_op/#pyobsidian.adder_op.OpMkHeader","title":"<code>OpMkHeader(operator: str)</code>","text":"<p>               Bases: <code>Op</code></p> <p>Adder operator mkheader.</p> <p>From the operator is obtained: </p> <ul> <li>Precedence represents whether it will be added before or after. '|&gt;' or '&lt;|'</li> <li>The level indicates the header level (1, 2, 3 etc)</li> <li>The index represents which level will be applied.</li> </ul> <p>For example OpMkHeader('|&gt;{3}h2') creates precedence '|&gt;', level 2 and index 3 The translation of this operator would be \"after the third h2\".</p> <p>This structure can be used by AdderWhere to add content based on the order of headers.</p> <p>Parameters:</p> <ul> <li> <code>operator</code>               (<code>str</code>)           \u2013            <p>The operator string.</p> </li> </ul> Source code in <code>pyobsidian/adder_op.py</code> <pre><code>def __init__(self: Self, operator: str):\n    self.__raw_operator = operator\n    self.__operator = self.build_operator(operator)\n</code></pre>"},{"location":"reference/adder_op/#pyobsidian.adder_op.OpMkHeader.build_operator","title":"<code>build_operator(operator: str) -&gt; dict[str, str]</code>","text":"<p>Build the operator.</p> <p>Parameters:</p> <ul> <li> <code>operator</code>               (<code>str</code>)           \u2013            <p>The operator string.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, str]</code>           \u2013            <p>The operator.</p> </li> </ul> Source code in <code>pyobsidian/adder_op.py</code> <pre><code>def build_operator(self: Self, operator: str) -&gt; dict[str, str]:\n    \"\"\"Build the operator.\n\n    Parameters\n    ----------\n    operator : str\n        The operator string.\n\n    Returns\n    -------\n    dict[str, str]\n        The operator.\n    \"\"\"\n    pattern = r'([\\&lt;\\&gt;]?\\|[\\&lt;\\&gt;]?)\\{([0-9]+)\\}h([1-6])'\n    match  = re.match(pattern, operator)\n    if match is None:\n        raise ValueError(f\"Invalid operator: '{operator}'\", \"Must be pattern like '([\\&lt;\\&gt;]?\\|[\\&lt;\\&gt;]?)\\{([0-9]+)\\}h([1-6])'. Example: '|&gt;{1}h1'\")\n    elif len(match[1]) != 2:\n        message = f\"Invalid operator in '{operator}'. Must be '|&gt;' or '&lt;|'.\"\n        message = message + '\\n' + textwrap.dedent(\"In your case, it should be '|&gt;{\")\n        message = message + f\"{match[3]}\" + \"}\" + f\"h{match[2]}' or '&lt;|\" + \"{\" + f\"{match[3]}\" + \"}\" + f\"h{match[2]}'\"\n        raise ValueError(message)\n    else:\n        return {\n        'precedence': str(match[1]),\n        'level': str(match[3]),\n        'index': str(match[2])\n    }\n</code></pre>"},{"location":"reference/filter/","title":"filter","text":"<p>This module contains the classes that represent Obsidian filters. Filters are used to search through Obsidian notes.  See searchby to understand how filters are used.</p> <p>A filter is composed of one or more fields, each field having an associated mode. Each field has a key, value, and occurrence.</p> <ul> <li>key: The key of the field. Defines which search method will be used. See get_search_strategies for more information.</li> <li>value: The value of the field. Values that will be searched based on the chosen search method</li> <li>occurrence: The occurrence of the field value. Can be 'inline', 'yaml', or 'file'.<ul> <li>inline: occurs inline</li> <li>yaml: occurs in yaml</li> <li>file: both inline and yaml</li> </ul> </li> </ul>"},{"location":"reference/filter/#pyobsidian.filter.Field","title":"<code>Field(key: FieldKey, value: FieldValue, occurrence: FieldOcurrence)</code>","text":"<p>Represents a filter field.</p> <p>Parameters:</p> <ul> <li> <code>key</code>               (<code>FieldKey</code>)           \u2013            <p>The key of the field</p> </li> <li> <code>value</code>               (<code>FieldValue</code>)           \u2013            <p>The value of the field</p> </li> <li> <code>occurrence</code>               (<code>FieldOcurrence</code>)           \u2013            <p>The occurrence of the field</p> </li> </ul> Source code in <code>pyobsidian/filter.py</code> <pre><code>def __init__(\n    self: Self, \n    key: FieldKey, \n    value: FieldValue, \n    occurrence: FieldOcurrence\n) -&gt; None:\n    self.__key = key\n    self.__value = value\n    self.__occurrence = occurrence\n</code></pre>"},{"location":"reference/filter/#pyobsidian.filter.Field.key","title":"<code>key: FieldKey</code>  <code>property</code>","text":"<p>The key of the field</p>"},{"location":"reference/filter/#pyobsidian.filter.Field.occurrence","title":"<code>occurrence: FieldOcurrence</code>  <code>property</code>","text":"<p>The occurrence of the field</p>"},{"location":"reference/filter/#pyobsidian.filter.Field.value","title":"<code>value: FieldValue</code>  <code>property</code>","text":"<p>The value of the field</p>"},{"location":"reference/filter/#pyobsidian.filter.Filter","title":"<code>Filter(fields: list[FilterField] = [])</code>","text":"<p>Represents a filter for notes.</p> <p>Parameters:</p> <ul> <li> <code>fields</code>               (<code>list[FilterField]</code>, default:                   <code>[]</code> )           \u2013            <p>The list of filter fields</p> </li> </ul> Source code in <code>pyobsidian/filter.py</code> <pre><code>def __init__(self: Self, fields: list[FilterField] = []):\n    self.__fields = fields\n</code></pre>"},{"location":"reference/filter/#pyobsidian.filter.Filter.fields","title":"<code>fields: list[FilterField]</code>  <code>property</code>","text":"<p>The list of filter fields for the current object.</p> <p>Returns:</p> <ul> <li> <code>list[FilterField]</code>           \u2013            <p>The list of filter fields for the current object.</p> </li> </ul>"},{"location":"reference/filter/#pyobsidian.filter.Filter.add_field","title":"<code>add_field(field: FilterField) -&gt; Filter</code>","text":"<p>Adds a new filter field to the filter and returns a new Filter object.</p> <p>Parameters:</p> <ul> <li> <code>field</code>               (<code>FilterField</code>)           \u2013            <p>The filter field to be added.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Filter</code>           \u2013            <p>A new Filter object with the added filter field.</p> </li> </ul> Source code in <code>pyobsidian/filter.py</code> <pre><code>def add_field(self: Self, field: FilterField) -&gt; Filter:\n    \"\"\"Adds a new filter field to the filter and returns a new Filter object.\n\n    Parameters\n    ----------\n    field : FilterField\n        The filter field to be added.\n\n    Returns\n    -------\n    Filter\n        A new Filter object with the added filter field.\n    \"\"\"\n    cur_fields = self.fields\n    new_fields = cur_fields + [field]\n    new_filter = Filter(new_fields)\n    return new_filter\n</code></pre>"},{"location":"reference/filter/#pyobsidian.filter.FilterField","title":"<code>FilterField(field: Field, mode: FilterMode)</code>  <code>dataclass</code>","text":"<p>Represents a filter field.</p> <p>Parameters:</p> <ul> <li> <code>field</code>               (<code>Field</code>)           \u2013            <p>The filter field</p> </li> <li> <code>mode</code>               (<code>FilterMode</code>)           \u2013            <p>The mode of the filter</p> </li> </ul>"},{"location":"reference/formatter/","title":"formatter","text":"<p>This module contains the classes that represent formatters.</p> <p>Formatters are used to format the content that will be added in notes.</p>"},{"location":"reference/formatter/#pyobsidian.formatter.Formatter","title":"<code>Formatter</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Base class for all formatters.</p>"},{"location":"reference/formatter/#pyobsidian.formatter.Formatter.format","title":"<code>format(value: str | list[str]) -&gt; str | list[str]</code>  <code>abstractmethod</code>","text":"<p>Format the content.</p> <p>Parameters:</p> <ul> <li> <code>value</code>               (<code>str | list[str]</code>)           \u2013            <p>The content to format.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str | list[str]</code>           \u2013            <p>The formatted content.</p> </li> </ul> Source code in <code>pyobsidian/formatter.py</code> <pre><code>@abstractmethod\ndef format(self: Self, value: str | list[str]) -&gt; str | list[str]:\n    \"\"\"Format the content.\n\n    Parameters\n    ----------\n    value : str | list[str]\n        The content to format.\n\n    Returns\n    -------\n    str | list[str]\n        The formatted content.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/formatter/#pyobsidian.formatter.FormatterContentInline","title":"<code>FormatterContentInline</code>","text":"<p>               Bases: <code>Formatter</code></p> <p>This formatter adds two line breaks at the beginning and end.</p>"},{"location":"reference/formatter/#pyobsidian.formatter.FormatterRelatedNoteInline","title":"<code>FormatterRelatedNoteInline</code>","text":"<p>               Bases: <code>Formatter</code></p> <p>This formatter adds \"[[\" and \"]]\" to each word entered and adds two line breaks at the beginning and end.</p>"},{"location":"reference/formatter/#pyobsidian.formatter.FormatterRelatedNoteOpMkHeader","title":"<code>FormatterRelatedNoteOpMkHeader</code>","text":"<p>               Bases: <code>FormatterRelatedNoteInline</code></p> <p>This formatter adds \"[[\" and \"]]\" to each word entered and adds two line breaks at the beginning and end.</p>"},{"location":"reference/formatter/#pyobsidian.formatter.FormatterRelatedNoteYaml","title":"<code>FormatterRelatedNoteYaml</code>","text":"<p>               Bases: <code>Formatter</code></p> <p>This formatter adds \"[[\" and \"]]\" to each word entered and convert to list.</p>"},{"location":"reference/formatter/#pyobsidian.formatter.FormatterTagInline","title":"<code>FormatterTagInline</code>","text":"<p>               Bases: <code>Formatter</code></p> <p>This formatter adds \"#\" to each word entered and adds two line breaks at the beginning and end.</p>"},{"location":"reference/formatter/#pyobsidian.formatter.FormatterTagOpMkHeader","title":"<code>FormatterTagOpMkHeader</code>","text":"<p>               Bases: <code>FormatterTagInline</code></p> <p>This formatter adds \"#\" to each word entered and adds two line breaks at the beginning and end.</p>"},{"location":"reference/formatter/#pyobsidian.formatter.FormatterYaml","title":"<code>FormatterYaml</code>","text":"<p>               Bases: <code>Formatter</code></p> <p>This formatter just converts the content to list.</p>"},{"location":"reference/helpers/","title":"helpers","text":"<p>This module contains helper functions.</p>"},{"location":"reference/helpers/#pyobsidian.helpers.convert_str_or_list_to_list","title":"<code>convert_str_or_list_to_list(value: str | list[str]) -&gt; list[str]</code>","text":"<p>Convert a string or a list of strings to a list of strings.</p> <p>Parameters:</p> <ul> <li> <code>value</code>               (<code>str | list[str]</code>)           \u2013            <p>The value to be converted.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[str]</code>           \u2013            <p>A list of strings.</p> </li> </ul> Source code in <code>pyobsidian/helpers.py</code> <pre><code>def convert_str_or_list_to_list(value: str | list[str]) -&gt; list[str]:\n    \"\"\"Convert a string or a list of strings to a list of strings.\n\n    Parameters\n    ----------\n    value : str | list[str]\n        The value to be converted.\n\n    Returns\n    -------\n    list[str]\n        A list of strings.\n    \"\"\"\n    if isinstance(value, str):\n        return [value]\n    else:\n        return value\n</code></pre>"},{"location":"reference/helpers/#pyobsidian.helpers.has_yaml","title":"<code>has_yaml(content: str) -&gt; bool</code>","text":"<p>Check if the given content has YAML.</p> <p>Parameters:</p> <ul> <li> <code>content</code>               (<code>str</code>)           \u2013            <p>The content to be checked.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if the content has YAML, False otherwise.</p> </li> </ul> Source code in <code>pyobsidian/helpers.py</code> <pre><code>def has_yaml(content: str) -&gt; bool:\n    \"\"\"Check if the given content has YAML.\n\n    Parameters\n    ----------\n    content : str\n        The content to be checked.\n\n    Returns\n    -------\n    bool\n        True if the content has YAML, False otherwise.\n    \"\"\"\n    re_compile = re.compile(r'---(.*?)---', re.DOTALL)\n    re_findall = re.findall(re_compile, content)\n    if len(re_findall) == 0:\n        return False\n    return True\n</code></pre>"},{"location":"reference/helpers/#pyobsidian.helpers.read_file","title":"<code>read_file(path: str) -&gt; str</code>","text":"<p>Read the content of a file.</p> <p>Parameters:</p> <ul> <li> <code>path</code>               (<code>str</code>)           \u2013            <p>The path of the file to be read.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>The content of the file.</p> </li> </ul> Source code in <code>pyobsidian/helpers.py</code> <pre><code>def read_file(path: str) -&gt; str:\n    \"\"\"Read the content of a file.\n\n    Parameters\n    ----------\n    path : str\n        The path of the file to be read.\n\n    Returns\n    -------\n    str\n        The content of the file.\n    \"\"\"\n    with open(path, 'r', encoding='utf8') as file:\n         content = file.read()\n    return content\n</code></pre>"},{"location":"reference/markdown/","title":"markdown","text":"<p>This module contains the classes that manipulate markdown content.</p>"},{"location":"reference/markdown/#pyobsidian.markdown.MkHeaderLevels","title":"<code>MkHeaderLevels(markdown: str)</code>","text":"<p>Get the levels of the headers in a markdown.</p> <p>Parameters:</p> <ul> <li> <code>markdown</code>               (<code>str</code>)           \u2013            <p>The markdown string to parse.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>MkLevel</code>           \u2013            <p>The levels of the headers in the markdown.</p> </li> </ul> Source code in <code>pyobsidian/markdown.py</code> <pre><code>def __init__(self: Self, markdown: str) -&gt; None:\n    self.__markdown = markdown\n</code></pre>"},{"location":"reference/markdown/#pyobsidian.markdown.MkHeaderLevels.markdown","title":"<code>markdown: str</code>  <code>property</code>","text":"<p>Markdown parsed.</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>The markdown parsed.</p> </li> </ul>"},{"location":"reference/markdown/#pyobsidian.markdown.MkHeaderLevels.pattern","title":"<code>pattern: str</code>  <code>property</code>","text":"<p>The pattern to match the headers.</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>The pattern to match the headers.</p> </li> </ul>"},{"location":"reference/markdown/#pyobsidian.markdown.MkHeaderLevels.get_headers","title":"<code>get_headers(markdown: str, pattern: re.Pattern[str]) -&gt; MkHeader</code>  <code>staticmethod</code>","text":"<p>Get the headers in the markdown string.</p> <p>Parameters:</p> <ul> <li> <code>markdown</code>               (<code>str</code>)           \u2013            <p>The markdown string to parse.</p> </li> <li> <code>pattern</code>               (<code>Pattern[str]</code>)           \u2013            <p>The pattern to match the headers.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>MkHeader</code>           \u2013            <p>The headers in the markdown string.</p> </li> </ul> Source code in <code>pyobsidian/markdown.py</code> <pre><code>@staticmethod\ndef get_headers(markdown: str, pattern: re.Pattern[str]) -&gt; MkHeader:\n    \"\"\"Get the headers in the markdown string.\n\n    Parameters\n    ----------\n    markdown : str\n        The markdown string to parse.\n    pattern : re.Pattern[str]\n        The pattern to match the headers.\n\n    Returns\n    -------\n    MkHeader\n        The headers in the markdown string.\n    \"\"\"\n    headers = [\n        {\n            'start': m.start(), \n            'end': m.end(),\n            'level': len(m.group(1)),\n            'content': m.group(2)\n        }\n        for m in re.finditer(pattern, markdown)\n    ]\n    return headers\n</code></pre>"},{"location":"reference/markdown/#pyobsidian.markdown.MkHeaderLevels.get_levels","title":"<code>get_levels() -&gt; MkLevel</code>","text":"<p>Get the levels of the headers in the markdown string.</p> <p>Returns:</p> <ul> <li> <code>MkLevel</code>           \u2013            <p>The levels of the headers in the markdown string.</p> </li> </ul> Source code in <code>pyobsidian/markdown.py</code> <pre><code>def get_levels(self: Self) -&gt; MkLevel:\n    \"\"\"Get the levels of the headers in the markdown string.\n\n    Returns\n    -------\n    MkLevel\n        The levels of the headers in the markdown string.\n    \"\"\"\n    result: MkLevel = {}\n    c_pattern = re.compile(self.pattern, re.MULTILINE)\n    headers = self.get_headers(self.markdown, c_pattern)        \n    for header in headers:\n        level = str(header['level'])\n        if level not in result:\n            result[level] = []\n        result[level].append({\n            'start': header['start'],\n            'end': header['end'],\n            'content': header['content']\n        })\n    return result\n</code></pre>"},{"location":"reference/markdown/#pyobsidian.markdown.parse_markdown","title":"<code>parse_markdown(markdown: str) -&gt; str</code>","text":"<p>Parse the markdown string.</p> <p>Parameters:</p> <ul> <li> <code>markdown</code>               (<code>str</code>)           \u2013            <p>The markdown string to parse.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>The parsed markdown string.</p> </li> </ul> Source code in <code>pyobsidian/markdown.py</code> <pre><code>def parse_markdown(markdown: str) -&gt; str:\n    \"\"\"Parse the markdown string.\n\n    Parameters\n    ----------\n    markdown : str\n        The markdown string to parse.\n\n    Returns\n    -------\n    str\n        The parsed markdown string.\n    \"\"\"\n    return '\\\\n'.join(markdown.split('\\\\n'))\n</code></pre>"},{"location":"reference/note/","title":"note","text":"<p>This module contains the classes that represent Obsidian notes. It provides classes for reading, writing, and retrieving properties of Obsidian notes.</p>"},{"location":"reference/note/#pyobsidian.note.Note","title":"<code>Note(path: str, content: Optional[str] = None)</code>","text":"<p>Represents a note in Obsidian vault.</p> <p>Parameters:</p> <ul> <li> <code>path</code>               (<code>str</code>)           \u2013            <p>The path of the note.</p> </li> <li> <code>content</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>The content of the note. If not provided, it will be read from the note file.</p> </li> </ul> Source code in <code>pyobsidian/note.py</code> <pre><code>def __init__(self: Self, path: str, content: Optional[str] = None):\n    if content is None:\n        content = read_file(path)\n    self.__path = path\n    self.__properties = NoteProperties(path, content)\n</code></pre>"},{"location":"reference/note/#pyobsidian.note.Note.path","title":"<code>path: str</code>  <code>property</code>","text":"<p>Retrieves the normalized path of the note.</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>The normalized path of the note.</p> </li> </ul>"},{"location":"reference/note/#pyobsidian.note.Note.properties","title":"<code>properties: NoteProperties</code>  <code>property</code>","text":"<p>Retrieves the properties of the note.</p> <p>Returns:</p> <ul> <li> <code>NoteProperties</code>           \u2013            <p>The properties of the note.</p> </li> </ul>"},{"location":"reference/note/#pyobsidian.note.Note.read","title":"<code>read() -&gt; str</code>","text":"<p>Reads the content of a note from the file.</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>The content of the note file</p> </li> </ul> Source code in <code>pyobsidian/note.py</code> <pre><code>def read(self: Self) -&gt; str:\n    \"\"\"Reads the content of a note from the file.\n\n    Returns\n    -------\n    str\n        The content of the note file\n    \"\"\"\n    return read_file(self.path)\n</code></pre>"},{"location":"reference/note/#pyobsidian.note.Note.write","title":"<code>write() -&gt; str</code>","text":"<p>Writes the content of a note to the file.</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>The path of the written note</p> </li> </ul> Source code in <code>pyobsidian/note.py</code> <pre><code>def write(self: Self) -&gt; str:\n    \"\"\"Writes the content of a note to the file.\n\n    Returns\n    -------\n    str\n        The path of the written note\n    \"\"\"\n    with open(self.path, 'w', encoding='utf8') as file:\n        file.write(self.properties.content)\n    return self.path\n</code></pre>"},{"location":"reference/note/#pyobsidian.note.NoteProperties","title":"<code>NoteProperties(path: str, content: str)</code>","text":"<p>A class used to retrieve properties of Obsidian notes.</p> <p>Parameters:</p> <ul> <li> <code>path</code>               (<code>str</code>)           \u2013            <p>The path of the note file</p> </li> <li> <code>content</code>               (<code>str</code>)           \u2013            <p>The content of the note file</p> </li> </ul> Source code in <code>pyobsidian/note.py</code> <pre><code>def __init__(self: Self, path: str, content: str):\n    self.__path = path\n    self.__content = content\n</code></pre>"},{"location":"reference/note/#pyobsidian.note.NoteProperties.content","title":"<code>content: str</code>  <code>property</code> <code>writable</code>","text":"<p>The content of the note file</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>The content of the note file</p> </li> </ul>"},{"location":"reference/note/#pyobsidian.note.NoteProperties.creation_time","title":"<code>creation_time: datetime</code>  <code>property</code>","text":"<p>Retrieves the creation time of the note file.</p> Notes <p>It uses the <code>os.path.getctime</code> function to retrieve the creation time of the file.</p> <p>Returns:</p> <ul> <li> <code>datetime</code>           \u2013            <p>The creation time of the note file.</p> </li> </ul>"},{"location":"reference/note/#pyobsidian.note.NoteProperties.filename","title":"<code>filename: str</code>  <code>property</code>","text":"<p>Returns the filename of the current object's path.</p> <p>This property takes the path of the current object and splits it using the operating system's path separator. It then extracts the last element of the resulting list, which represents the filename. The filename is further split using the dot separator to remove the file extension. The function then returns the extracted filename as a string.</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>Note filename.</p> </li> </ul>"},{"location":"reference/note/#pyobsidian.note.NoteProperties.folder","title":"<code>folder: list[str]</code>  <code>property</code>","text":"<p>Retrieves the folders path of the current note as a list of strings. All combinations of the folder path are returned. For example, if the folder path is \"C:/Users/user/vault\", it returns ['C:', 'C:/Users', 'C:/Users/user', 'C:/Users/user/vault']</p> <p>Returns:</p> <ul> <li> <code>list[str]</code>           \u2013            <p>A list containing the folders path of the current note.</p> </li> </ul>"},{"location":"reference/note/#pyobsidian.note.NoteProperties.last_access_time","title":"<code>last_access_time: datetime</code>  <code>property</code>","text":"<p>Retrieves the last access time of the file.</p> Notes <p>It uses the <code>os.path.getatime</code> function to retrieve the last access time of the file.</p> <p>Returns:</p> <ul> <li> <code>datetime</code>           \u2013            <p>The last access time of the file.</p> </li> </ul>"},{"location":"reference/note/#pyobsidian.note.NoteProperties.last_modification_time","title":"<code>last_modification_time: datetime</code>  <code>property</code>","text":"<p>Retrieves the last modification time of the file.</p> Notes <p>It uses the <code>os.path.getmtime</code> function to retrieve the last modification time of the file.</p> <p>Returns:</p> <ul> <li> <code>datetime</code>           \u2013            <p>The last modification time of the file.</p> </li> </ul>"},{"location":"reference/note/#pyobsidian.note.NoteProperties.path","title":"<code>path: str</code>  <code>property</code>","text":"<p>The path of the note file</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>The path of the note file</p> </li> </ul>"},{"location":"reference/note/#pyobsidian.note.NoteProperties.related_note","title":"<code>related_note: dict[str, Optional[list[str]] | Optional[dict[str, list[str]]]]</code>  <code>property</code>","text":"<p>Retrieves related notes from both YAML content and inline content.</p> <p>This property returns a dictionary containing the related notes extracted from both the YAML content and inline content of the note. The dictionary has two keys: - 'yaml': The related notes extracted from the YAML content of the note. It is a dictionary where the keys are the YAML keys and the values are lists of related note names. - 'inline': The related notes extracted from the inline content of the note. It is a list of related note names.</p> <p>Returns:</p> <ul> <li> <code>dict[str, Union[list[str], dict[str, list[str]]]]</code>           \u2013            <p>A dictionary containing the related notes extracted from both the YAML content and inline content of the note.</p> </li> </ul>"},{"location":"reference/note/#pyobsidian.note.NoteProperties.tag","title":"<code>tag: dict[str, Optional[list[str]]]</code>  <code>property</code>","text":"<p>Retrieves the tags from the note.</p> <p>This property returns a dictionary containing the tags extracted from the note. The dictionary has two keys:</p> <ul> <li>'yaml': The tags extracted from the YAML content of the note. It is a list of strings or None if no tags are found.</li> <li>'inline': The tags extracted from the inline content of the note. It is a list of strings or None if no tags are found.</li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, Optional[list[str]]]</code>           \u2013            <p>A dictionary containing the tags extracted from the note.</p> </li> </ul>"},{"location":"reference/note/#pyobsidian.note.NoteProperties.yaml_content","title":"<code>yaml_content: Optional[dict]</code>  <code>property</code>","text":"<p>Retrieves the YAML content from the note. The YAML is identified by '---'. All text between these two delimiters is considered part of the YAML content. If more than one '---' separator is found, only the first pair is considered.</p> Notes <p>See Obsidian properties for more details.</p> <p>Returns:</p> <ul> <li> <code>Optional[dict]</code>           \u2013            <p>The YAML content of the note, or None if no YAML content is found.</p> </li> </ul>"},{"location":"reference/note/#pyobsidian.note.NoteProperties._get_related_notes_inline","title":"<code>_get_related_notes_inline() -&gt; Optional[list[str]]</code>","text":"<p>Retrieves all the related notes that are inline in the content of the note.</p> <p>This function uses regular expressions to find all occurrences of related notes in the content of the note. The related notes are identified by the pattern [[note|alias]], where 'note' is the name of the related note and 'alias' is an optional alias for the note. The function removes the alias from the related note and returns a list of the related notes without aliases.</p> <p>Returns:</p> <ul> <li> <code>Optional[list[str]]</code>           \u2013            <p>A list of related notes found in the content, without aliases, or None if no related notes are found.</p> </li> </ul> Source code in <code>pyobsidian/note.py</code> <pre><code>def _get_related_notes_inline(self: Self) -&gt; Optional[list[str]]:\n    \"\"\"Retrieves all the related notes that are inline in the content of the note.\n\n    This function uses regular expressions to find all occurrences of related notes in the content of the note.\n    The related notes are identified by the pattern [[note|alias]], where 'note' is the name of the related note and 'alias' is an optional alias for the note.\n    The function removes the alias from the related note and returns a list of the related notes without aliases.\n\n    Returns\n    -------\n    Optional[list[str]]\n        A list of related notes found in the content, without aliases, or None if no related notes are found.\n    \"\"\"\n    re_compile = re.compile(r'---(.*?)---', re.DOTALL)\n    raw_content = re.sub(re_compile, '', self.content)\n    regex = re.compile(r'\\[\\[(.*?)\\]\\]')\n    related_notes = regex.findall(raw_content)\n    if len(related_notes) == 0:\n        return None\n    related_notes_without_alias = [\n        note.split('|')[0] \n        for note in related_notes\n    ]\n    return related_notes_without_alias\n</code></pre>"},{"location":"reference/note/#pyobsidian.note.NoteProperties._get_related_notes_yaml","title":"<code>_get_related_notes_yaml() -&gt; Optional[dict[str, list[str]]]</code>","text":"<p>Retrieves related notes from YAML content.</p> <p>This function searches for related notes in the YAML content of the note. It uses regular expressions to find all occurrences of related notes in the YAML content. The related notes are identified by the pattern [[note|alias]], where 'note' is the name of the related note and 'alias' is an optional alias for the note. The function removes the alias from the related note and returns a dictionary of the related notes, grouped by the YAML key.</p> <p>Returns:</p> <ul> <li> <code>Optional[dict[str, list[str]]]</code>           \u2013            <p>A dictionary of related notes found in the YAML content, grouped by the YAML key, or None if no related notes are found.</p> </li> </ul> Source code in <code>pyobsidian/note.py</code> <pre><code>def _get_related_notes_yaml(self: Self) -&gt; Optional[ dict[str, list[str]] ]:\n    \"\"\"Retrieves related notes from YAML content.\n\n    This function searches for related notes in the YAML content of the note.\n    It uses regular expressions to find all occurrences of related notes in the YAML content.\n    The related notes are identified by the pattern [[note|alias]], where 'note' is the name of the related note and 'alias' is an optional alias for the note.\n    The function removes the alias from the related note and returns a dictionary of the related notes, grouped by the YAML key.\n\n    Returns\n    -------\n    Optional[dict[str, list[str]]]\n        A dictionary of related notes found in the YAML content, grouped by the YAML key, or None if no related notes are found.\n    \"\"\"\n    yaml_content = self.yaml_content\n    if yaml_content is None:\n        return None\n\n    def rec_search(values, compile: re.Pattern = re.compile(r'\\[\\[(.*?)\\]\\]')) -&gt; list[str]:\n        results = []\n        if isinstance(values, str):\n            related_notes = re.findall(compile, values)\n            related_notes_without_alias = [\n                note.split('|')[0] \n                for note in related_notes\n            ]\n            results.extend(related_notes_without_alias)\n        elif isinstance(values, list):\n            for value in values:\n                results.extend(rec_search(value))\n        return results\n\n    related_notes = {}\n    for key, values in yaml_content.items():\n        related_notes[key] = rec_search(values)\n\n    valid_related_notes = {\n        key: values\n        for key, values in related_notes.items()\n        if len(values) &gt; 0\n    }\n    if len(valid_related_notes) == 0:\n        return None\n    return valid_related_notes\n</code></pre>"},{"location":"reference/note/#pyobsidian.note.NoteProperties._get_tags_inline","title":"<code>_get_tags_inline() -&gt; Optional[list[str]]</code>","text":"<p>Retrieves all the inline tags from the content of the note.</p> <p>This function uses regular expressions to find all occurrences of tags in the content of the note. The tags are identified by the pattern '#tag', where 'tag' is any non-whitespace sequence of characters.</p> <p>Returns:</p> <ul> <li> <code>Optional[list[str]]</code>           \u2013            <p>A list of tags found in the content, or None if no tags are found.</p> </li> </ul> Source code in <code>pyobsidian/note.py</code> <pre><code>def _get_tags_inline(self: Self) -&gt; Optional[list[str]]:\n    \"\"\"Retrieves all the inline tags from the content of the note.\n\n    This function uses regular expressions to find all occurrences of tags in the content of the note.\n    The tags are identified by the pattern '#tag', where 'tag' is any non-whitespace sequence of characters.\n\n    Returns\n    -------\n    Optional[list[str]]\n        A list of tags found in the content, or None if no tags are found.\n    \"\"\"\n    tags = re.compile(r'#([^\\s]+)')\n    tags_content = tags.findall(self.content)\n    if len(tags_content) == 0:\n        return None\n    return tags_content\n</code></pre>"},{"location":"reference/note/#pyobsidian.note.NoteProperties._get_tags_yaml","title":"<code>_get_tags_yaml() -&gt; Optional[list[str]]</code>","text":"<p>Retrieves the tags from the YAML content of the note.</p> <p>Returns:</p> <ul> <li> <code>Optional[list[str]]</code>           \u2013            <p>The list of tags if they exist in the YAML content,  otherwise None.</p> </li> </ul> Source code in <code>pyobsidian/note.py</code> <pre><code>def _get_tags_yaml(self: Self) -&gt; Optional[list[str]]:\n    \"\"\"Retrieves the tags from the YAML content of the note.\n\n    Returns\n    -------\n    Optional[list[str]]\n        The list of tags if they exist in the YAML content, \n        otherwise None.\n    \"\"\"\n    yaml_tags = self._get_yaml_field('tags')\n    if isinstance(yaml_tags, str):\n        yaml_tags = [yaml_tags]\n    return yaml_tags\n</code></pre>"},{"location":"reference/note/#pyobsidian.note.NoteProperties._get_yaml_field","title":"<code>_get_yaml_field(field: str) -&gt; Optional[str | list[str]]</code>","text":"<p>Retrieves the value of a specified field from the YAML content of the note.</p> <p>Parameters:</p> <ul> <li> <code>field</code>               (<code>str</code>)           \u2013            <p>The name of the field to retrieve the value of.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Optional[str | list[str]]</code>           \u2013            <p>The value of the specified field if it exists in the YAML content,  otherwise None.</p> </li> </ul> Source code in <code>pyobsidian/note.py</code> <pre><code>def _get_yaml_field(self: Self, field: str) -&gt; Optional[str | list[str]]:\n    \"\"\"Retrieves the value of a specified field from the YAML content of the note.\n\n    Parameters\n    ----------\n    field : str\n        The name of the field to retrieve the value of.\n\n    Returns\n    -------\n    Optional[str | list[str]]\n        The value of the specified field if it exists in the YAML content, \n        otherwise None.\n    \"\"\"\n    if self.yaml_content is None:\n        return None\n    field_value = self.yaml_content.get(field)\n    return field_value\n</code></pre>"},{"location":"reference/searchby/","title":"searchby","text":"<p>This module contains the classes that represent Obsidian search strategies.</p> <p>A search strategy define how Filter are applied to Vault.</p> <p>A generic interface for search strategies is provided by the SearchBy class.</p>"},{"location":"reference/searchby/#pyobsidian.searchby.SearchBy","title":"<code>SearchBy</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Interface for search strategies.</p>"},{"location":"reference/searchby/#pyobsidian.searchby.SearchBy.__search","title":"<code>__search(notes: list[Note], field: Field) -&gt; list[Note]</code>","text":"<p>Mechanism for the search.</p> <p>It's used by the <code>search</code> method.</p> <p>Parameters:</p> <ul> <li> <code>notes</code>               (<code>list[Note]</code>)           \u2013            <p>A list of notes to search through.</p> </li> <li> <code>field</code>               (<code>Field</code>)           \u2013            <p>The field to search for.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[Note]</code>           \u2013            <p>A list of notes that match the field value.</p> </li> </ul> Source code in <code>pyobsidian/searchby.py</code> <pre><code>def __search(self, notes: list[Note], field: Field) -&gt; list[Note]:\n    \"\"\"Mechanism for the search.\n\n    It's used by the `search` method.\n\n    Parameters\n    ----------\n    notes : list[Note]\n        A list of notes to search through.\n    field : Field\n        The field to search for.\n\n    Returns\n    -------\n    list[Note]\n        A list of notes that match the field value.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/searchby/#pyobsidian.searchby.SearchBy.condition","title":"<code>condition(note: Note, field: Field) -&gt; bool</code>","text":"<p>Function that implements the condition of the search.</p> <p>Parameters:</p> <ul> <li> <code>note</code>               (<code>Note</code>)           \u2013            <p>The note to be checked.</p> </li> <li> <code>field</code>               (<code>Field</code>)           \u2013            <p>The field to be checked.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if the condition is met, False otherwise.</p> </li> </ul> Source code in <code>pyobsidian/searchby.py</code> <pre><code>def condition(self: Self, note: Note, field: Field) -&gt; bool:\n    \"\"\"Function that implements the condition of the search.\n\n    Parameters\n    ----------\n    note : Note\n        The note to be checked.\n    field : Field\n        The field to be checked.\n\n    Returns\n    -------\n    bool\n        True if the condition is met, False otherwise.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/searchby/#pyobsidian.searchby.SearchBy.convert_field_value_to_list","title":"<code>convert_field_value_to_list(value: FieldValue) -&gt; FieldValue</code>  <code>staticmethod</code>","text":"<p>Convert the given field value to a list if it's a string.</p> <p>Parameters:</p> <ul> <li> <code>value</code>               (<code>FieldValue</code>)           \u2013            <p>The field value to be converted.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[str]</code>           \u2013            <p>A list of strings.</p> </li> </ul> Source code in <code>pyobsidian/searchby.py</code> <pre><code>@staticmethod\ndef convert_field_value_to_list(value: FieldValue) -&gt; FieldValue:\n    \"\"\"Convert the given field value to a list if it's a string.\n\n    Parameters\n    ----------\n    value : FieldValue\n        The field value to be converted.\n\n    Returns\n    -------\n    list[str]\n        A list of strings.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/searchby/#pyobsidian.searchby.SearchBy.is_valid_value","title":"<code>is_valid_value(value: FieldValue) -&gt; bool</code>","text":"<p>Check if the given value is a valid field value.</p> <p>Parameters:</p> <ul> <li> <code>value</code>               (<code>FieldValue</code>)           \u2013            <p>The value to be checked.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if the value is valid, False otherwise.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the value is not a string or a list.</p> </li> </ul> Source code in <code>pyobsidian/searchby.py</code> <pre><code>def is_valid_value(self: Self, value: FieldValue) -&gt; bool:\n    \"\"\"Check if the given value is a valid field value.\n\n    Parameters\n    ----------\n    value : FieldValue\n        The value to be checked.\n\n    Returns\n    -------\n    bool\n        True if the value is valid, False otherwise.\n\n    Raises\n    ------\n    ValueError\n        If the value is not a string or a list.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/searchby/#pyobsidian.searchby.SearchBy.search","title":"<code>search(notes: list[Note], field: Field) -&gt; list[Note]</code>","text":"<p>Search for notes that match the given field value.</p> <p>The implementation is given by the <code>__search</code> method.</p> <p>Parameters:</p> <ul> <li> <code>notes</code>               (<code>list[Note]</code>)           \u2013            <p>A list of notes to search through.</p> </li> <li> <code>field</code>               (<code>Field</code>)           \u2013            <p>The field to search for.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[Note]</code>           \u2013            <p>A list of notes that match the field value.</p> </li> </ul> Source code in <code>pyobsidian/searchby.py</code> <pre><code>def search(self: Self, notes: list[Note], field: Field,) -&gt; list[Note]:\n    \"\"\"Search for notes that match the given field value.\n\n    The implementation is given by the `__search` method.\n\n    Parameters\n    ----------\n    notes : list[Note]\n        A list of notes to search through.\n    field : Field\n        The field to search for.\n\n    Returns\n    -------\n    list[Note]\n        A list of notes that match the field value.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/searchby/#pyobsidian.searchby.SearchByContent","title":"<code>SearchByContent</code>","text":"<p>               Bases: <code>SearchByDefault</code></p> <p>Search by note properties content</p>"},{"location":"reference/searchby/#pyobsidian.searchby.SearchByDate","title":"<code>SearchByDate</code>","text":"<p>               Bases: <code>SearchByDefault</code></p> <p>Search by note properties date</p>"},{"location":"reference/searchby/#pyobsidian.searchby.SearchByDate.__search","title":"<code>__search(notes: list[Note], field: Field) -&gt; list[Note]</code>","text":"<p>Date search mechanism.</p> <p>In this mechanism, same logic as the <code>SearchByDefault</code> class is used. However, the field values \u200b\u200bare not traversed as the list is passed to the <code>condition</code>.</p> <p>A set is used to remove potential duplicates.</p> Source code in <code>pyobsidian/searchby.py</code> <pre><code>def __search(self, notes: list[Note], field: Field) -&gt; list[Note]:\n    \"\"\"Date search mechanism.\n\n    In this mechanism, same logic as the `SearchByDefault` class is used.\n    However, the field values \u200b\u200bare not traversed as the list is passed to the `condition`.\n\n    A set is used to remove potential duplicates.\n    \"\"\"\n    filtered_notes = []\n    for note in notes:\n        if self.condition(note, field):\n            filtered_notes.append(note)\n    return list(set(filtered_notes))\n</code></pre>"},{"location":"reference/searchby/#pyobsidian.searchby.SearchByDate.condition","title":"<code>condition(note: Note, field: Field) -&gt; bool</code>","text":"<p>Condition check if note date propertie is between start and end date.</p> <p>First element from field value is the date propertie. Second and third elements from field value are start and end date respectively.</p> <p>Parameters:</p> <ul> <li> <code>note</code>               (<code>Note</code>)           \u2013            <p>The note to be checked.</p> </li> <li> <code>field</code>               (<code>Field</code>)           \u2013            <p>The field to be checked.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if the note date propertie is between start and end date, False otherwise.</p> </li> </ul> Source code in <code>pyobsidian/searchby.py</code> <pre><code>def condition(self: Self, note: Note, field: Field) -&gt; bool:\n    \"\"\"Condition check if note date propertie is between start and end date.\n\n    First element from field value is the date propertie.\n    Second and third elements from field value are start and end date respectively.\n\n    Parameters\n    ----------\n    note : Note\n        The note to be checked.\n    field : Field\n        The field to be checked.\n\n    Returns\n    -------\n    bool\n        True if the note date propertie is between start and end date, False otherwise.\n    \"\"\"\n    value = field.value\n    date_propertie = value[0]\n    start_date = datetime.strptime(value[1], '%Y-%m-%d')\n    end_date = datetime.strptime(value[2], '%Y-%m-%d')\n    note_date = getattr(note.properties, date_propertie)\n    return note_date &gt;= start_date and note_date &lt;= end_date\n</code></pre>"},{"location":"reference/searchby/#pyobsidian.searchby.SearchByDate.is_valid_value","title":"<code>is_valid_value(value: FieldValue) -&gt; bool</code>","text":"<p>Check if the given value is a valid date field value.</p> <p>Parameters:</p> <ul> <li> <code>value</code>               (<code>FieldValue</code>)           \u2013            <p>The value to be checked.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if the value is valid, False otherwise.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the value is not a list with 3 elements</p> </li> </ul> Source code in <code>pyobsidian/searchby.py</code> <pre><code>def is_valid_value(self: Self, value: FieldValue) -&gt; bool:\n    \"\"\"Check if the given value is a valid date field value.\n\n    Parameters\n    ----------\n    value : FieldValue\n        The value to be checked.\n\n    Returns\n    -------\n    bool\n        True if the value is valid, False otherwise.\n\n    Raises\n    ------\n    ValueError\n        If the value is not a list with 3 elements\n    \"\"\"\n    if not isinstance(value, list):\n        raise ValueError(f'`{value}` must be a list')\n    if len(value) != 3:\n        raise ValueError(f'`{value}` must be a list with 3 elements: [\\'date_propertie\\', \\'start_date\\', \\'end_date\\']')\n    if isinstance(value, list) and len(value) == 3:\n        return True\n    raise ValueError(f'`{value}` must be a list with 3 elements: [\\'date_propertie\\', \\'start_date\\', \\'end_date\\']')\n</code></pre>"},{"location":"reference/searchby/#pyobsidian.searchby.SearchByDefault","title":"<code>SearchByDefault</code>","text":"<p>               Bases: <code>SearchBy</code></p> <p>Default search strategy. Acts as a template for other search strategies.</p>"},{"location":"reference/searchby/#pyobsidian.searchby.SearchByDefault.__search","title":"<code>__search(notes: list[Note], field: Field) -&gt; list[Note]</code>","text":"<p>Default search mechanism.</p> <p>In this mechanism, each value of the field is checked against the notes. If the value is found in the note, it is added to the filtered notes list.</p> <p>A set is used to remove potential duplicates.</p> Source code in <code>pyobsidian/searchby.py</code> <pre><code>def __search(self, notes: list[Note], field: Field) -&gt; list[Note]:\n    \"\"\"Default search mechanism.\n\n    In this mechanism, each value of the field is checked against the\n    notes. If the value is found in the note, it is added to the\n    filtered notes list.\n\n    A set is used to remove potential duplicates.\n    \"\"\"\n    values = self.convert_field_value_to_list(field.value)\n    filtered_notes = []\n    for value in values:\n        cur_field = Field(field.key, value, field.occurrence)\n        for note in notes:\n            if self.condition(note, cur_field):\n                filtered_notes.append(note)\n    return list(set(filtered_notes))\n</code></pre>"},{"location":"reference/searchby/#pyobsidian.searchby.SearchByDefault.condition","title":"<code>condition(note: Note, field: Field) -&gt; bool</code>","text":"<p>Default condition check if field value is in the note properties.</p> Source code in <code>pyobsidian/searchby.py</code> <pre><code>def condition(self: Self, note: Note, field: Field) -&gt; bool:\n    \"\"\"Default condition check if field value is in the note properties.\"\"\"\n    return field.value in getattr(note.properties, field.key)\n</code></pre>"},{"location":"reference/searchby/#pyobsidian.searchby.SearchByDefault.is_valid_value","title":"<code>is_valid_value(value: FieldValue) -&gt; bool</code>","text":"<p>Default check if a string or a list. If not, raise an error.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if the value is valid, False otherwise.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the value is not a string or a list.</p> </li> </ul> Source code in <code>pyobsidian/searchby.py</code> <pre><code>def is_valid_value(self: Self, value: FieldValue) -&gt; bool:\n    \"\"\"Default check if a string or a list. If not, raise an error.\n\n    Returns\n    -------\n    bool\n        True if the value is valid, False otherwise.\n\n    Raises\n    ------\n    ValueError\n        If the value is not a string or a list.\n    \"\"\"\n    if not isinstance(value, str) and not isinstance(value, list):\n        raise ValueError(f'`{value}` must be a string or a list')\n    return True\n</code></pre>"},{"location":"reference/searchby/#pyobsidian.searchby.SearchByFolder","title":"<code>SearchByFolder</code>","text":"<p>               Bases: <code>SearchByDefault</code></p> <p>Search by note properties folder</p>"},{"location":"reference/searchby/#pyobsidian.searchby.SearchByFolder.condition","title":"<code>condition(note: Note, field: Field) -&gt; bool</code>","text":"<p>Condition check if any value of field value is in the note properties folder.</p> Source code in <code>pyobsidian/searchby.py</code> <pre><code>def condition(self: Self, note: Note, field: Field) -&gt; bool:\n    \"\"\"Condition check if any value of field value is in the note properties folder.\"\"\"\n    norm_value = os.path.normpath(str(field.value))\n    attrs = getattr(note.properties, field.key)\n    return any([norm_value in attr for attr in attrs])\n</code></pre>"},{"location":"reference/searchby/#pyobsidian.searchby.SearchByOccurrence","title":"<code>SearchByOccurrence</code>","text":"<p>               Bases: <code>SearchByDefault</code></p> <p>Occurrence search strategy.</p> <p>Acts as a template for search strategies that need to check if the field value is in the note properties that occurs inline, yaml or both.</p>"},{"location":"reference/searchby/#pyobsidian.searchby.SearchByOccurrence.condition","title":"<code>condition(note: Note, field: Field) -&gt; bool</code>","text":"<p>Condition check if any value of field value is in the note properties that occurs inline, yaml or both.</p> <p>Use the same <code>search</code> method as the <code>SearchByDefault</code> class.</p> Source code in <code>pyobsidian/searchby.py</code> <pre><code>def condition(self: Self, note: Note, field: Field) -&gt; bool:\n    \"\"\"Condition check if any value of field value is in the note properties that occurs inline, yaml or both.\n\n    Use the same `search` method as the `SearchByDefault` class.\n    \"\"\"\n    inline = getattr(note.properties, field.key)['inline']\n    yaml = getattr(note.properties, field.key)['yaml']\n    check_inline = field.value in inline if inline else False\n    check_yaml = field.value in yaml if yaml else False\n    match field.occurrence:\n        case 'inline':\n            return check_inline\n        case 'yaml':\n            return check_yaml\n        case 'file':\n            return check_inline or check_yaml\n        case _:\n            raise ValueError(f'`{field.occurrence}` is not a valid tag occurrence')\n</code></pre>"},{"location":"reference/searchby/#pyobsidian.searchby.SearchByRegex","title":"<code>SearchByRegex</code>","text":"<p>               Bases: <code>SearchByDefault</code></p> <p>Search by regex in note properties content</p>"},{"location":"reference/searchby/#pyobsidian.searchby.SearchByRegex.condition","title":"<code>condition(note: Note, field: Field) -&gt; bool</code>","text":"<p>Condition check regex pattern matches in note properties content.</p> Source code in <code>pyobsidian/searchby.py</code> <pre><code>def condition(self: Self, note: Note, field: Field) -&gt; bool:\n    \"\"\"Condition check regex pattern matches in note properties content.\"\"\"\n    attr = getattr(note.properties, 'content')\n    return any(re.findall(str(field.value), attr))\n</code></pre>"},{"location":"reference/searchby/#pyobsidian.searchby.SearchByTag","title":"<code>SearchByTag</code>","text":"<p>               Bases: <code>SearchByOccurrence</code></p> <p>Search by note properties tag inline, yaml or both</p>"},{"location":"reference/searchby/#pyobsidian.searchby.get_search_strategies","title":"<code>get_search_strategies() -&gt; dict[FieldKey, SearchBy]</code>","text":"<p>Define a dict of search strategies</p> <p>Returns:</p> <ul> <li> <code>dict[FieldKey, SearchBy]</code>           \u2013            <p>The dict of search strategies</p> </li> </ul> Source code in <code>pyobsidian/searchby.py</code> <pre><code>def get_search_strategies() -&gt; dict[FieldKey, SearchBy]:\n    \"\"\"Define a dict of search strategies\n\n    Returns\n    -------\n    dict[FieldKey, SearchBy]\n        The dict of search strategies\n    \"\"\"\n    return {\n        'folder': SearchByFolder(),\n        'content': SearchByContent(),\n        'regex': SearchByRegex(),\n        'date': SearchByDate(),\n        'tag': SearchByTag(),\n        'related_note': SearchByRelatedNote()\n    }\n</code></pre>"},{"location":"reference/vault/","title":"vault","text":"<p>This module contains the classes that represent Obsidian vaults.</p> <p>A vault is a collection of notes that can be searched through.</p>"},{"location":"reference/vault/#pyobsidian.vault.Vault","title":"<code>Vault(path: str, notes: list[Note] = [], filter: Filter = Filter(), adder: Adder = Adder())</code>","text":"<p>A class that represents an Obsidian vault.</p> <p>Parameters:</p> <ul> <li> <code>path</code>               (<code>str</code>)           \u2013            <p>The path of the vault.</p> </li> <li> <code>notes</code>               (<code>list[Note]</code>, default:                   <code>[]</code> )           \u2013            <p>The list of notes in the vault</p> </li> <li> <code>filter</code>               (<code>Filter</code>, default:                   <code>Filter()</code> )           \u2013            <p>The filter applied to the vault</p> </li> </ul> Source code in <code>pyobsidian/vault.py</code> <pre><code>def __init__(\n    self: Self,\n    path: str,\n    notes: list[Note] = [],\n    filter: Filter = Filter(),\n    adder: Adder = Adder()\n) -&gt; None:\n    self.__path = path\n    self.__notes = notes\n    self.__filter = filter\n    self.__adder = adder\n</code></pre>"},{"location":"reference/vault/#pyobsidian.vault.Vault.adder","title":"<code>adder: Adder</code>  <code>property</code>","text":"<p>The adder applied to the vault</p> <p>Returns:</p> <ul> <li> <code>Filter</code>           \u2013            <p>The adder applied to the vault</p> </li> </ul>"},{"location":"reference/vault/#pyobsidian.vault.Vault.adder_strategies","title":"<code>adder_strategies: dict[AdderKey, AdderWhere]</code>  <code>property</code>","text":"<p>The adder strategies used by the vault</p> <p>Returns:</p> <ul> <li> <code>dict[AdderKey, AdderWhere]</code>           \u2013            <p>The adder strategies used by the vault</p> </li> </ul>"},{"location":"reference/vault/#pyobsidian.vault.Vault.filter","title":"<code>filter: Filter</code>  <code>property</code>","text":"<p>The filter applied to the vault</p> <p>Returns:</p> <ul> <li> <code>Filter</code>           \u2013            <p>The filter applied to the vault</p> </li> </ul>"},{"location":"reference/vault/#pyobsidian.vault.Vault.formatters","title":"<code>formatters: dict[tuple[str, str], Formatter]</code>  <code>property</code>","text":"<p>The formatters used by the vault</p> <p>Returns:</p> <ul> <li> <code>dict[tuple[str, str], Formatter]</code>           \u2013            <p>The formatters used by the vault</p> </li> </ul>"},{"location":"reference/vault/#pyobsidian.vault.Vault.notes","title":"<code>notes: list[Note]</code>  <code>property</code>","text":"<p>The list of notes in the vault</p> <p>Returns:</p> <ul> <li> <code>list[Note]</code>           \u2013            <p>The list of notes in the vault</p> </li> </ul>"},{"location":"reference/vault/#pyobsidian.vault.Vault.path","title":"<code>path: str</code>  <code>property</code>","text":"<p>The path of the vault</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>The path of the vault</p> </li> </ul>"},{"location":"reference/vault/#pyobsidian.vault.Vault.search_strategies","title":"<code>search_strategies: dict[FieldKey, SearchBy]</code>  <code>property</code>","text":"<p>The search strategies used by the vault</p> <p>Returns:</p> <ul> <li> <code>dict[FieldKey, SearchBy]</code>           \u2013            <p>The search strategies used by the vault</p> </li> </ul>"},{"location":"reference/vault/#pyobsidian.vault.Vault.__search","title":"<code>__search(notes: list[Note], field: Field) -&gt; list[Note]</code>","text":"<p>A function that searches for notes based on a given field using a specific search strategy.</p> <p>Parameters:</p> <ul> <li> <code>notes</code>               (<code>list[Note]</code>)           \u2013            <p>A list of notes to search through.</p> </li> <li> <code>field</code>               (<code>Field</code>)           \u2013            <p>The field to search for.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[Note]</code>           \u2013            <p>A list of notes that match the search criteria.</p> </li> </ul> Source code in <code>pyobsidian/vault.py</code> <pre><code>def __search(\n    self,\n    notes: list[Note], \n    field: Field\n) -&gt; list[Note]:\n    \"\"\"A function that searches for notes based on a given field using a specific search strategy.\n\n    Parameters\n    ----------\n    notes : list[Note]\n        A list of notes to search through.\n    field : Field\n        The field to search for.\n\n    Returns\n    -------\n    list[Note]\n        A list of notes that match the search criteria.\n    \"\"\"\n    search_strategy = self.search_strategies[field.key]\n    notes = search_strategy.search(notes, field)\n    return notes\n</code></pre>"},{"location":"reference/vault/#pyobsidian.vault.Vault.add","title":"<code>add(by: AdderKey, value: AdderValue, where: Literal['inline', 'yaml'] | Op) -&gt; Vault</code>","text":"<p>Add a new adder field to current adder.</p> <p><code>by</code>, <code>value</code> and <code>where</code> build the field to add.</p> <ul> <li>by is used to find which AdderWhere to add to.</li> <li>value is the value to add.</li> <li>where is the where to add the value: inline, yaml or an Op.</li> </ul> <p>Parameters:</p> <ul> <li> <code>by</code>               (<code>AdderKey</code>)           \u2013            <p>The field to add by.</p> </li> <li> <code>value</code>               (<code>AdderValue</code>)           \u2013            <p>The value to add.</p> </li> <li> <code>where</code>               (<code>Literal['inline', 'yaml'] | Op</code>)           \u2013            <p>The where to add the field.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Vault</code>           \u2013            <p>A new Vault object with the new adder field added.</p> </li> </ul> Source code in <code>pyobsidian/vault.py</code> <pre><code>def add(\n    self: Self, \n    by: AdderKey, \n    value: AdderValue,\n    where: Literal['inline', 'yaml'] | Op\n) -&gt; Vault:\n    \"\"\"Add a new adder field to current adder.\n\n    `by`, `value` and `where` build the field to add.\n\n    - by is used to find which AdderWhere to add to.\n    - value is the value to add.\n    - where is the where to add the value: inline, yaml or an Op.\n\n    Parameters\n    ----------\n    by : AdderKey\n        The field to add by.\n    value : AdderValue\n        The value to add.\n    where : Literal['inline', 'yaml'] | Op\n        The where to add the field.\n\n    Returns\n    -------\n    Vault\n        A new Vault object with the new adder field added.\n    \"\"\"\n    if isinstance(where, Op):\n        adder_field = AdderField(by, value, (where.id, where))\n    else:\n        adder_field = AdderField(by, value, where)\n    cur_adder = self.adder\n    new_adder = cur_adder.add_field(adder_field)\n    new_vault = Vault(path=self.path, notes=self.notes, filter=self.filter, adder=new_adder)\n    return new_vault\n</code></pre>"},{"location":"reference/vault/#pyobsidian.vault.Vault.add_new_adder_strategy","title":"<code>add_new_adder_strategy(name: AdderKey, strategy: AdderWhere) -&gt; dict[str, AdderWhere]</code>  <code>classmethod</code>","text":"<p>Adds a new adder strategy to Vault class.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>AdderKey</code>)           \u2013            <p>The name of the new adder strategy.</p> </li> <li> <code>strategy</code>               (<code>AdderField</code>)           \u2013            <p>The adder strategy to be added.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, AdderWhere]</code>           \u2013            <p>The updated adder strategies.</p> </li> </ul> Source code in <code>pyobsidian/vault.py</code> <pre><code>@classmethod\ndef add_new_adder_strategy(\n    cls: type[Self],\n    name: AdderKey,\n    strategy: AdderWhere\n) -&gt; dict[str, AdderWhere]:\n    \"\"\"Adds a new adder strategy to Vault class.\n\n    Parameters\n    ----------\n    name : AdderKey\n        The name of the new adder strategy.\n    strategy : AdderField\n        The adder strategy to be added.\n\n    Returns\n    -------\n    dict[str, AdderWhere]\n        The updated adder strategies.\n    \"\"\"\n    cls.__adder_strategies.registry.add_registry(name, strategy)\n    return cls.__adder_strategies.registry.where\n</code></pre>"},{"location":"reference/vault/#pyobsidian.vault.Vault.add_new_formatter","title":"<code>add_new_formatter(name: str, where: str, formatter: Formatter) -&gt; dict[tuple[str, str], Formatter]</code>  <code>classmethod</code>","text":"<p>Adds a new adder formatter to Vault class.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>AdderKey</code>)           \u2013            <p>The name of the new adder formatter.</p> </li> <li> <code>formatter</code>               (<code>AdderField</code>)           \u2013            <p>The formatter to be added.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[tuple[str, str], Formatter]</code>           \u2013            <p>The updated adder formatters.</p> </li> </ul> Source code in <code>pyobsidian/vault.py</code> <pre><code>@classmethod\ndef add_new_formatter(\n    cls: type[Self],\n    name: str,\n    where: str,\n    formatter: Formatter\n) -&gt; dict[tuple[str, str], Formatter]:\n    \"\"\"Adds a new adder formatter to Vault class.\n\n    Parameters\n    ----------\n    name : AdderKey\n        The name of the new adder formatter.\n    formatter : AdderField\n        The formatter to be added.\n\n    Returns\n    -------\n    dict[tuple[str, str], Formatter]\n        The updated adder formatters.\n    \"\"\"\n    cls.__adder_strategies.registry.add_formatter(name, where, formatter)\n    return cls.__adder_strategies.registry.formatters\n</code></pre>"},{"location":"reference/vault/#pyobsidian.vault.Vault.add_new_search_strategy","title":"<code>add_new_search_strategy(name: FieldKey, strategy: SearchBy) -&gt; dict[FieldKey, SearchBy]</code>  <code>classmethod</code>","text":"<p>Adds a new search strategy to Vault class.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>FieldKey</code>)           \u2013            <p>The name of the new search strategy.</p> </li> <li> <code>strategy</code>               (<code>SearchBy</code>)           \u2013            <p>The search strategy to be added.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[FieldKey, SearchBy]</code>           \u2013            <p>The updated search strategies.</p> </li> </ul> Source code in <code>pyobsidian/vault.py</code> <pre><code>@classmethod\ndef add_new_search_strategy(\n    cls: type[Self],\n    name: FieldKey,\n    strategy: SearchBy\n) -&gt; dict[FieldKey, SearchBy]:\n    \"\"\"Adds a new search strategy to Vault class.\n\n    Parameters\n    ----------\n    name : FieldKey\n        The name of the new search strategy.\n    strategy : SearchBy\n        The search strategy to be added.\n\n    Returns\n    -------\n    dict[FieldKey, SearchBy]\n        The updated search strategies.\n    \"\"\"\n    cls.__search_strategies[name] = strategy\n    new_strategy = cls.__search_strategies\n    return new_strategy\n</code></pre>"},{"location":"reference/vault/#pyobsidian.vault.Vault.execute","title":"<code>execute() -&gt; Vault</code>","text":"<p>This method applies the filter and adder to the current Vault object.</p> <p>First, all filter fields are applied. Then, all adder fields are applied.</p> <p>Returns:</p> <ul> <li> <code>Vault</code>           \u2013            <p>A new Vault object with the filter applied.</p> </li> </ul> Source code in <code>pyobsidian/vault.py</code> <pre><code>def execute(self: Self) -&gt; Vault:        \n    \"\"\"This method applies the filter and adder to the current Vault object.\n\n    First, all filter fields are applied. Then, all adder fields are applied.\n\n    Returns\n    -------\n    Vault\n        A new Vault object with the filter applied.\n    \"\"\"\n    filter = self.filter\n    if not filter:\n        return self\n    notes = self.notes\n    if not notes:\n        notes = self.get_notes()\n\n    filtered_notes = notes\n    new_notes: list[Note] = []\n    for f_field in filter:\n        mode = f_field.mode\n        if mode == 'and':\n            new_notes = self.__search(new_notes or filtered_notes, f_field.field)\n        elif mode == 'or':\n            new_notes.extend(self.__search(notes, f_field.field))\n        else:\n            raise ValueError(f'`{mode}` is not a valid mode. Must be `and` or `or`')\n    unique_new_notes = list(set(new_notes))\n\n    adder = self.adder\n    if not adder:\n        return Vault(path=self.path, notes=unique_new_notes, filter=filter, adder=Adder())\n    for note in unique_new_notes:\n        for add in adder:\n            key = add.key\n            value = add.value\n            where = add.where\n            formatter = adder.registry.get_formatter(key, where)\n            adder_where = adder.registry.get_where(where)\n            if adder_where is None:\n                message = textwrap.dedent(f\"\"\"\n                    Invalid where: '{where}' in `.add('{key}', {value}, '{where}')`\n                    Checking in {adder.registry.where} I found {list(adder.registry.where.keys())}.\n                    Hints:\n                        - Check that you haven't made any typing errors.\n                        - Check if AdderWhere implementation exists.\n                        - If you don't find it, add new adder strategy.\n                            - To do this, implement your own AdderWhere.\n                            - Use Vault.add_new_adder_strategy()\n                \"\"\")\n                raise ValueError(message)\n            if formatter is None:\n                message = textwrap.dedent(f\"\"\"\n                    Invalid formatter: \"{(key, where)}\" in `.add('{key}', {value}, '{where}')`\n                    Checking in {adder.registry.formatters} I found {list(adder.registry.formatters.keys())}.\n                    I need a Formatter to format the value because this operation will modify the content of the note.\n                    In your case, you need to implement at least a Formatter for '{key}' with '{where}'.\n                    Hints:\n                        - Check that you haven't made any typing errors.\n                        - Check if Formatter implementation exists.\n                        - If you don't find it, add new formatter.\n                            - To do this, implement your own Formatter. \n                            - Use Vault.add_new_adder_formatter()\n                \"\"\")\n                raise ValueError(message)\n            new_value = formatter.format(value)\n            new_field = AdderField(key, new_value, where)\n            new_content = adder_where.exec(note, new_field)\n            if new_content is None:\n                continue\n            note.properties.content = new_content\n        note.write()\n    return Vault(path=self.path, notes=unique_new_notes, filter=filter, adder=Adder())\n</code></pre>"},{"location":"reference/vault/#pyobsidian.vault.Vault.find_by","title":"<code>find_by(by: FieldKey, value: FieldValue, occurrence: FieldOcurrence = 'file', mode: FilterMode = 'and') -&gt; Vault</code>","text":"<p>Add a new filter field to current filter.</p> <p><code>by</code>, <code>value</code> and <code>occurrence</code> build the field to search for. mode is used to specify how the filter should be applied. If mode is 'and' (default) the filter will be applied in current vault notes. If mode is 'or' the filter will be applied in all vault notes. This can be used to create complex filters. The sequence of the filter fields will be preserved.</p> <p>For example vault.find_by('folder', 'folder1').find_by('folder', 'folder2'). In this case, the filter will be applied to search for notes in folder1. After that, the filter will be applied in notes that are returned by first filter, returning notes in folder2. This example is equivalent to finding notes that are in 'folder2' which is a subfolder of 'folder1'. </p> <p>If mode is 'or' the filter will be applied to search for notes in folder1 or folder2.</p> <p>Parameters:</p> <ul> <li> <code>by</code>               (<code>FieldKey</code>)           \u2013            <p>The field to search by.</p> </li> <li> <code>value</code>               (<code>FieldValue</code>)           \u2013            <p>The value to search for.</p> </li> <li> <code>occurrence</code>               (<code>FieldOcurrence</code>, default:                   <code>'file'</code> )           \u2013            <p>The occurrence of the value to search for. Defaults to 'file'.</p> </li> <li> <code>mode</code>               (<code>FilterMode</code>, default:                   <code>'and'</code> )           \u2013            <p>The mode of the filter. Defaults to 'and'.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Vault</code>           \u2013            <p>A new Vault object with the new filter field added.</p> </li> </ul> Source code in <code>pyobsidian/vault.py</code> <pre><code>def find_by(\n    self: Self, \n    by: FieldKey, \n    value: FieldValue,\n    occurrence: FieldOcurrence = 'file',\n    mode: FilterMode='and'\n) -&gt; Vault:\n    \"\"\"Add a new filter field to current filter.\n\n    `by`, `value` and `occurrence` build the field to search for.\n    mode is used to specify how the filter should be applied.\n    If mode is 'and' (default) the filter will be applied in current vault notes.\n    If mode is 'or' the filter will be applied in all vault notes.\n    This can be used to create complex filters.\n    The sequence of the filter fields will be preserved.\n\n    For example vault.find_by('folder', 'folder1').find_by('folder', 'folder2').\n    In this case, the filter will be applied to search for notes in folder1.\n    After that, the filter will be applied in notes that are returned by first filter, returning notes in folder2.\n    This example is equivalent to finding notes that are in 'folder2' which is a subfolder of 'folder1'. \n\n    If mode is 'or' the filter will be applied to search for notes in folder1 or folder2.\n\n    Parameters\n    ----------\n    by : FieldKey\n        The field to search by.\n    value : FieldValue\n        The value to search for.\n    occurrence : FieldOcurrence, optional\n        The occurrence of the value to search for. Defaults to 'file'.\n    mode : FilterMode, optional\n        The mode of the filter. Defaults to 'and'.\n\n    Returns\n    -------\n    Vault\n        A new Vault object with the new filter field added.\n    \"\"\"\n    field = Field(by, value, occurrence)\n    filter_field = FilterField(field, mode)\n    cur_filter = self.filter\n    new_filter = cur_filter.add_field(filter_field)\n    new_vault = Vault(path=self.path, notes=self.notes, filter=new_filter)\n    return new_vault\n</code></pre>"},{"location":"reference/vault/#pyobsidian.vault.Vault.get_notes","title":"<code>get_notes(extension: str = '.md') -&gt; list[Note]</code>","text":"<p>Retrieves a list of notes from the specified vault directory.</p> <p>Parameters:</p> <ul> <li> <code>extension</code>               (<code>str</code>, default:                   <code>'.md'</code> )           \u2013            <p>The file extension to filter the notes by. Defaults to '.md'.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[Note]</code>           \u2013            <p>A list of Note objects representing the notes found in the vault directory.</p> </li> </ul> Source code in <code>pyobsidian/vault.py</code> <pre><code>def get_notes(self: Self, extension: str='.md') -&gt; list[Note]:\n    \"\"\"Retrieves a list of notes from the specified vault directory.\n\n    Parameters\n    ----------\n    extension : str, optional\n        The file extension to filter the notes by. Defaults to '.md'.\n\n    Returns\n    -------\n    list[Note]\n        A list of Note objects representing the notes found in the vault directory.\n    \"\"\"\n    root = self.path\n    notes = []\n    for root, _, filenames in os.walk(root):\n        for filename in filenames:\n            if filename.endswith(extension):\n                note_path = os.path.join(root, filename)\n                notes.append(Note(note_path))\n    return notes\n</code></pre>"}]}