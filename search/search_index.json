{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"pyobsidian","text":""},{"location":"#overview","title":"Overview","text":"<p><code>pyobsidian</code> is a python library for working with Obsidian vaults. It's allows you to find and manipulate any note in your Obsidian vault.</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install pyobsidian\n</code></pre>"},{"location":"#usage","title":"Usage","text":"<p>A common workflow used in this library is define a vault, create a filter and execute it to find notes that match the filter conditions. This workflow can see bellow:</p> <p> </p> <p>This can be translated to code in a very simple way: <pre><code>&gt;&gt;&gt; from pyobsidian.vault import Vault\n&gt;&gt;&gt; vault = Vault('your/obsidian/vault/path')\n&gt;&gt;&gt; new_vault = (\n...    vault\n...    .find_by('folder', 'some_folder')\n...    .find_by('tag', 'some_tag')\n...    .execute()\n...)\n&gt;&gt;&gt; print(vault)\nVault(\n    path='your/obsidian/vault/path',\n    notes=[],\n    filter=Filter(),\n)\n&gt;&gt;&gt; print(new_vault)\nVault(\n    path='your/obsidian/vault/path',\n    notes=[Note(path='your/obsidian/vault/path/.../note.md')],\n    filter=Filter(\n        [\n            FilterField(Field(key='folder', value='some_folder', occurrence='file'), mode = 'and'),\n            FilterField(Field(key='tag', value='some_tag', occurrence='file'), mode = 'and')\n        ]\n    )\n)\n&gt;&gt;&gt; print(new_vault.notes)\n[Note(path='your/obsidian/vault/path/.../note.md')]\n</code></pre></p>"},{"location":"#getting-help","title":"Getting help","text":"<p>If you encounter a clear bug, please file an issue with a minimal reproducible example on GitHub.</p>"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"changelog/#011-2024-05-30","title":"[0.1.1] - 2024-05-30","text":""},{"location":"changelog/#removed","title":"Removed","text":"<ul> <li>Development packages from the build</li> </ul>"},{"location":"changelog/#010-2024-05-30","title":"[0.1.0] - 2024-05-30","text":""},{"location":"changelog/#added","title":"Added","text":"<ul> <li><code>Note</code> class to represent a note in Obsidian vault</li> <li><code>Filter</code> class to represent an filter</li> <li><code>SearchBy</code> class to represent search strategy</li> <li><code>Vault</code> class to represent an Obsidian vault</li> </ul>"},{"location":"license/","title":"License","text":"<p>MIT License</p> <p>Copyright (c) 2024 Matheus S. Rodrigues</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"articles/filter_mode/","title":"Understanding filter <code>mode</code>","text":"<p>One important argument used in filters is <code>mode</code>. In this section, we'll explore how it works.</p>"},{"location":"articles/filter_mode/#and-or-and","title":"And, or, and","text":"<p>Let's start example with a sequence of mode <code>and</code>, <code>or</code>, and <code>and</code>. An example of how this sequence could be obtained is shown below.</p> <pre><code>&gt;&gt;&gt; from pyobsidian.vault import Vault\n&gt;&gt;&gt; vault = Vault('your/obsidian/vault/path')\n&gt;&gt;&gt; new_vault = (\n...     vault\n...     .find_by('folder', 'x', 'and')\n...     .find_by('tag', 'y', 'or')\n...     .find_by('related_note', 'z', 'and')\n...     .execute()\n... )\n</code></pre> <p>Let's consider that the analyzed vault has 4 notes. The image below illustrates this scenario.</p> <p></p> <ul> <li>Filters with [A] represent filters that apply the \"and\" mode and [O] filters with \"or\" mode</li> <li>All notes with [ X ] represent notes that meet the filter criteria. Notes with [  ] do not meet the criteria</li> <li>Notes with [ ? ] are notes that the filter cannot yet evaluate because previous steps are necessary</li> </ul> <p>In this situation, note 1 meets the criteria of filter 1 and notes 1 and 4 meet the criteria of filter 2. Since filter 3 is applied after these filters, it does not yet know which notes will arrive to be evaluated. Therefore, it is not possible to know which notes meet the requirements of filter 3.</p> <p>After applying filters 1 and 2, the scenario below is obtained.</p> <p></p> <p>Due to the conditions of filters 1 and 2, only notes 1 and 4 can be seen by filter 3. And only note 4 meets the criteria of filter 3. As the last condition is an \"and\", only notes that meet the final application will remain. In this case, only grade 4 meets all these requirements. This way, the final result is a grade 4.</p> <p></p>"},{"location":"articles/filter_mode/#and-and-or","title":"And, and, or","text":"<p>Now we will try to approach this problem with another sequence of filters: and, and, or.</p> <p></p> <p>In this situation, only note 1 meets the criteria of filter 1, so only this note can be seen by filter 3 since an \"and\" is applied with it. However, note 1 does not meet the criteria of filter 3. As a result, the final result of these steps does not return any note. However, it is important to highlight that filter 2, as it is applied as \"or\", can see all the notes in the vault in question.</p> <p></p> <p>With this scenario, because the mode is \"or\", all notes that meet the criteria will be filtered. In this case, only the notes filtered by filter 2 will remain.</p> <p></p>"},{"location":"articles/filter_mode/#behaviors","title":"Behaviors","text":"<p>With these examples it is possible to note important characteristics when applying these modes:</p> <ul> <li>Filters applied with 'and' can only see the notes applied after the previous steps.</li> <li>Filters applied with 'or' can see all notes in the current vault.</li> </ul> <p>This behavior of 'or' can be changed by executing <code>execute</code> before applying all steps. For example: <pre><code>&gt;&gt;&gt; from pyobsidian.vault import Vault\n&gt;&gt;&gt; vault = Vault('your/obsidian/vault/path')\n&gt;&gt;&gt; new_vault = (\n...     vault\n...     .find_by('folder', 'x', 'and')\n...     .execute()\n...     .find_by('tag', 'y', 'or')\n...     .find_by('related_note', 'z', 'and')\n...     .execute()\n... )\n</code></pre></p> <p>The execute performs the searches, so the 'or' method will only see the notes after the 'folder' filter. With this manipulation it is possible to create complex filters that meet different criteria.</p>"},{"location":"articles/new_search_strategy/","title":"Creating new search strategy","text":"<p>Sometimes, you will need to customize search strategies. <code>pyobsidian</code> provides a way to do that.</p>"},{"location":"articles/new_search_strategy/#the-problem","title":"The problem","text":"<p>Suppose, for some reason, you need to search for notes that filename contains a pattern. There is no such method by default. So, you need to create a new search strategy.</p>"},{"location":"articles/new_search_strategy/#creating-new-strategy-with-default-implementation","title":"Creating new strategy with default implementation","text":"<p>All strategies follow the same interface: SearchBy. The following methods are defined in this interface:</p> <ul> <li><code>search(notes: list[Note], field: Field)</code></li> <li><code>condition(note: Note, field: Field)</code></li> <li><code>__search(notes: list[Note], field: Field)</code></li> <li><code>is_valid_value(value: FieldValue)</code></li> <li><code>convert_field_value_to_list(value: FieldValue)</code></li> </ul> <p>However, a template with default implementation is provided (<code>SearchByDefault</code>). This class implements the methods in a way that they will generally be used. We can use it as a template to create new search strategies!</p> <p>To do this, you will need to create a new class that inherits from <code>SearchByDefault</code> and implements <code>condition</code> method. For this hypothetical scenario, we would have:</p> <pre><code>&gt;&gt;&gt; from pyobsidian.searchby import SearchByDefault\n&gt;&gt;&gt; class SearchByFilenameRegex(SearchByDefault):\n...     def condition(self, note: Note, field: Field) -&gt; bool:\n...         attr = getattr(note.properties, 'filename')\n...         return any(re.findall(str(field.value), attr))\n</code></pre> <p>This simple code is enough to create a new search strategy. Now, you can add it to vault search strategies.</p> <pre><code>&gt;&gt;&gt; from pyobsidian.vault import Vault\n&gt;&gt;&gt; vault = Vault('your/obsidian/vault/path')\n&gt;&gt;&gt; vault.add_new_search_strategy(\n...     'filename_regex', \n...     SearchByFilenameRegex\n... )\n&gt;&gt;&gt; new_vault = (\n...     vault\n...     .find_by('filename_regex', 'test')\n...     .execute()\n... )\n&gt;&gt;&gt; notes_with_test_in_filename = new_vault.notes\n</code></pre>"},{"location":"reference/filter/","title":"filter","text":"<p>This module contains the classes that represent Obsidian filters. Filters are used to search through Obsidian notes.  See searchby to understand how filters are used.</p> <p>A filter is composed of one or more fields, each field having an associated mode. Each field has a key, value, and occurrence.</p> <ul> <li>key: The key of the field. Defines which search method will be used. See get_search_strategies for more information.</li> <li>value: The value of the field. Values that will be searched based on the chosen search method</li> <li>occurrence: The occurrence of the field value. Can be 'inline', 'yaml', or 'file'.<ul> <li>inline: occurs inline</li> <li>yaml: occurs in yaml</li> <li>file: both inline and yaml</li> </ul> </li> </ul>"},{"location":"reference/filter/#pyobsidian.filter.Field","title":"<code>Field(key: FieldKey, value: FieldValue, occurrence: FieldOcurrence)</code>","text":"<p>Represents a filter field.</p> <p>Parameters:</p> <ul> <li> <code>key</code>               (<code>FieldKey</code>)           \u2013            <p>The key of the field</p> </li> <li> <code>value</code>               (<code>FieldValue</code>)           \u2013            <p>The value of the field</p> </li> <li> <code>occurrence</code>               (<code>FieldOcurrence</code>)           \u2013            <p>The occurrence of the field</p> </li> </ul> Source code in <code>pyobsidian/filter.py</code> <pre><code>def __init__(\n    self: Self, \n    key: FieldKey, \n    value: FieldValue, \n    occurrence: FieldOcurrence\n) -&gt; None:\n    self.__key = key\n    self.__value = value\n    self.__occurrence = occurrence\n</code></pre>"},{"location":"reference/filter/#pyobsidian.filter.Field.key","title":"<code>key: FieldKey</code>  <code>property</code>","text":"<p>The key of the field</p>"},{"location":"reference/filter/#pyobsidian.filter.Field.occurrence","title":"<code>occurrence: FieldOcurrence</code>  <code>property</code>","text":"<p>The occurrence of the field</p>"},{"location":"reference/filter/#pyobsidian.filter.Field.value","title":"<code>value: FieldValue</code>  <code>property</code>","text":"<p>The value of the field</p>"},{"location":"reference/filter/#pyobsidian.filter.Filter","title":"<code>Filter(fields: list[FilterField] = [])</code>","text":"<p>Represents a filter for notes.</p> <p>Parameters:</p> <ul> <li> <code>fields</code>               (<code>list[FilterField]</code>, default:                   <code>[]</code> )           \u2013            <p>The list of filter fields</p> </li> </ul> Source code in <code>pyobsidian/filter.py</code> <pre><code>def __init__(self: Self, fields: list[FilterField] = []):\n    self.__fields = fields\n</code></pre>"},{"location":"reference/filter/#pyobsidian.filter.Filter.fields","title":"<code>fields: list[FilterField]</code>  <code>property</code>","text":"<p>The list of filter fields for the current object.</p> <p>Returns:</p> <ul> <li> <code>list[FilterField]</code>           \u2013            <p>The list of filter fields for the current object.</p> </li> </ul>"},{"location":"reference/filter/#pyobsidian.filter.Filter.add_field","title":"<code>add_field(field: FilterField) -&gt; Filter</code>","text":"<p>Adds a new filter field to the filter and returns a new Filter object.</p> <p>Parameters:</p> <ul> <li> <code>field</code>               (<code>FilterField</code>)           \u2013            <p>The filter field to be added.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Filter</code>           \u2013            <p>A new Filter object with the added filter field.</p> </li> </ul> Source code in <code>pyobsidian/filter.py</code> <pre><code>def add_field(self: Self, field: FilterField) -&gt; Filter:\n    \"\"\"Adds a new filter field to the filter and returns a new Filter object.\n\n    Parameters\n    ----------\n    field : FilterField\n        The filter field to be added.\n\n    Returns\n    -------\n    Filter\n        A new Filter object with the added filter field.\n    \"\"\"\n    cur_fields = self.fields\n    new_fields = cur_fields + [field]\n    new_filter = Filter(new_fields)\n    return new_filter\n</code></pre>"},{"location":"reference/filter/#pyobsidian.filter.FilterField","title":"<code>FilterField(field: Field, mode: FilterMode)</code>  <code>dataclass</code>","text":"<p>Represents a filter field.</p> <p>Parameters:</p> <ul> <li> <code>field</code>               (<code>Field</code>)           \u2013            <p>The filter field</p> </li> <li> <code>mode</code>               (<code>FilterMode</code>)           \u2013            <p>The mode of the filter</p> </li> </ul>"},{"location":"reference/note/","title":"note","text":"<p>This module contains the classes that represent Obsidian notes. It provides classes for reading, writing, and retrieving properties of Obsidian notes.</p>"},{"location":"reference/note/#pyobsidian.note.Note","title":"<code>Note(path: str)</code>","text":"<p>Represents a note in Obsidian vault.</p> <p>Parameters:</p> <ul> <li> <code>path</code>               (<code>str</code>)           \u2013            <p>The path of the note.</p> </li> </ul> Source code in <code>pyobsidian/note.py</code> <pre><code>def __init__(self: Self, path: str):\n    self.__reader = NoteReader(path)\n    self.__properties = NoteProperties(path, NoteReader(path).read())\n</code></pre>"},{"location":"reference/note/#pyobsidian.note.Note.path","title":"<code>path: str</code>  <code>property</code>","text":"<p>Retrieves the normalized path of the note.</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>The normalized path of the note.</p> </li> </ul>"},{"location":"reference/note/#pyobsidian.note.Note.properties","title":"<code>properties: NoteProperties</code>  <code>property</code>","text":"<p>Retrieves the properties of the note.</p> <p>Returns:</p> <ul> <li> <code>NoteProperties</code>           \u2013            <p>The properties of the note.</p> </li> </ul>"},{"location":"reference/note/#pyobsidian.note.NoteProperties","title":"<code>NoteProperties(path: str, content: str)</code>","text":"<p>A class used to retrieve properties of Obsidian notes.</p> <p>Parameters:</p> <ul> <li> <code>path</code>               (<code>str</code>)           \u2013            <p>The path of the note file</p> </li> <li> <code>content</code>               (<code>str</code>)           \u2013            <p>The content of the note file</p> </li> </ul> Source code in <code>pyobsidian/note.py</code> <pre><code>def __init__(self: Self, path: str, content: str):\n    self.__path = path\n    self.__content = content\n</code></pre>"},{"location":"reference/note/#pyobsidian.note.NoteProperties.content","title":"<code>content: str</code>  <code>property</code>","text":"<p>The content of the note file</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>The content of the note file</p> </li> </ul>"},{"location":"reference/note/#pyobsidian.note.NoteProperties.creation_time","title":"<code>creation_time: datetime</code>  <code>property</code>","text":"<p>Retrieves the creation time of the note file.</p> Notes <p>It uses the <code>os.path.getctime</code> function to retrieve the creation time of the file.</p> <p>Returns:</p> <ul> <li> <code>datetime</code>           \u2013            <p>The creation time of the note file.</p> </li> </ul>"},{"location":"reference/note/#pyobsidian.note.NoteProperties.filename","title":"<code>filename: str</code>  <code>property</code>","text":"<p>Returns the filename of the current object's path.</p> <p>This property takes the path of the current object and splits it using the operating system's path separator. It then extracts the last element of the resulting list, which represents the filename. The filename is further split using the dot separator to remove the file extension. The function then returns the extracted filename as a string.</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>Note filename.</p> </li> </ul>"},{"location":"reference/note/#pyobsidian.note.NoteProperties.folder","title":"<code>folder: list[str]</code>  <code>property</code>","text":"<p>Retrieves the folders path of the current note as a list of strings. All combinations of the folder path are returned. For example, if the folder path is \"C:/Users/user/vault\", it returns ['C:', 'C:/Users', 'C:/Users/user', 'C:/Users/user/vault']</p> <p>Returns:</p> <ul> <li> <code>list[str]</code>           \u2013            <p>A list containing the folders path of the current note.</p> </li> </ul>"},{"location":"reference/note/#pyobsidian.note.NoteProperties.last_access_time","title":"<code>last_access_time: datetime</code>  <code>property</code>","text":"<p>Retrieves the last access time of the file.</p> Notes <p>It uses the <code>os.path.getatime</code> function to retrieve the last access time of the file.</p> <p>Returns:</p> <ul> <li> <code>datetime</code>           \u2013            <p>The last access time of the file.</p> </li> </ul>"},{"location":"reference/note/#pyobsidian.note.NoteProperties.last_modification_time","title":"<code>last_modification_time: datetime</code>  <code>property</code>","text":"<p>Retrieves the last modification time of the file.</p> Notes <p>It uses the <code>os.path.getmtime</code> function to retrieve the last modification time of the file.</p> <p>Returns:</p> <ul> <li> <code>datetime</code>           \u2013            <p>The last modification time of the file.</p> </li> </ul>"},{"location":"reference/note/#pyobsidian.note.NoteProperties.path","title":"<code>path: str</code>  <code>property</code>","text":"<p>The path of the note file</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>The path of the note file</p> </li> </ul>"},{"location":"reference/note/#pyobsidian.note.NoteProperties.related_note","title":"<code>related_note: dict[str, Optional[list[str]] | Optional[dict[str, list[str]]]]</code>  <code>property</code>","text":"<p>Retrieves related notes from both YAML content and inline content.</p> <p>This property returns a dictionary containing the related notes extracted from both the YAML content and inline content of the note. The dictionary has two keys: - 'yaml': The related notes extracted from the YAML content of the note. It is a dictionary where the keys are the YAML keys and the values are lists of related note names. - 'inline': The related notes extracted from the inline content of the note. It is a list of related note names.</p> <p>Returns:</p> <ul> <li> <code>dict[str, Union[list[str], dict[str, list[str]]]]</code>           \u2013            <p>A dictionary containing the related notes extracted from both the YAML content and inline content of the note.</p> </li> </ul>"},{"location":"reference/note/#pyobsidian.note.NoteProperties.tag","title":"<code>tag: dict[str, Optional[list[str]]]</code>  <code>property</code>","text":"<p>Retrieves the tags from the note.</p> <p>This property returns a dictionary containing the tags extracted from the note. The dictionary has two keys:</p> <ul> <li>'yaml': The tags extracted from the YAML content of the note. It is a list of strings or None if no tags are found.</li> <li>'inline': The tags extracted from the inline content of the note. It is a list of strings or None if no tags are found.</li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, Optional[list[str]]]</code>           \u2013            <p>A dictionary containing the tags extracted from the note.</p> </li> </ul>"},{"location":"reference/note/#pyobsidian.note.NoteProperties.yaml_content","title":"<code>yaml_content: Optional[dict]</code>  <code>property</code>","text":"<p>Retrieves the YAML content from the note. The YAML is identified by '---'. All text between these two delimiters is considered part of the YAML content. If more than one '---' separator is found, only the first pair is considered.</p> Notes <p>See Obsidian properties for more details.</p> <p>Returns:</p> <ul> <li> <code>Optional[dict]</code>           \u2013            <p>The YAML content of the note, or None if no YAML content is found.</p> </li> </ul>"},{"location":"reference/note/#pyobsidian.note.NoteProperties._get_related_notes_inline","title":"<code>_get_related_notes_inline() -&gt; Optional[list[str]]</code>","text":"<p>Retrieves all the related notes that are inline in the content of the note.</p> <p>This function uses regular expressions to find all occurrences of related notes in the content of the note. The related notes are identified by the pattern [[note|alias]], where 'note' is the name of the related note and 'alias' is an optional alias for the note. The function removes the alias from the related note and returns a list of the related notes without aliases.</p> <p>Returns:</p> <ul> <li> <code>Optional[list[str]]</code>           \u2013            <p>A list of related notes found in the content, without aliases, or None if no related notes are found.</p> </li> </ul> Source code in <code>pyobsidian/note.py</code> <pre><code>def _get_related_notes_inline(self: Self) -&gt; Optional[list[str]]:\n    \"\"\"Retrieves all the related notes that are inline in the content of the note.\n\n    This function uses regular expressions to find all occurrences of related notes in the content of the note.\n    The related notes are identified by the pattern [[note|alias]], where 'note' is the name of the related note and 'alias' is an optional alias for the note.\n    The function removes the alias from the related note and returns a list of the related notes without aliases.\n\n    Returns\n    -------\n    Optional[list[str]]\n        A list of related notes found in the content, without aliases, or None if no related notes are found.\n    \"\"\"\n    re_compile = re.compile(r'---(.*?)---', re.DOTALL)\n    raw_content = re.sub(re_compile, '', self.content)\n    regex = re.compile(r'\\[\\[(.*?)\\]\\]')\n    related_notes = regex.findall(raw_content)\n    if len(related_notes) == 0:\n        return None\n    related_notes_without_alias = [\n        note.split('|')[0] \n        for note in related_notes\n    ]\n    return related_notes_without_alias\n</code></pre>"},{"location":"reference/note/#pyobsidian.note.NoteProperties._get_related_notes_yaml","title":"<code>_get_related_notes_yaml() -&gt; Optional[dict[str, list[str]]]</code>","text":"<p>Retrieves related notes from YAML content.</p> <p>This function searches for related notes in the YAML content of the note. It uses regular expressions to find all occurrences of related notes in the YAML content. The related notes are identified by the pattern [[note|alias]], where 'note' is the name of the related note and 'alias' is an optional alias for the note. The function removes the alias from the related note and returns a dictionary of the related notes, grouped by the YAML key.</p> <p>Returns:</p> <ul> <li> <code>Optional[dict[str, list[str]]]</code>           \u2013            <p>A dictionary of related notes found in the YAML content, grouped by the YAML key, or None if no related notes are found.</p> </li> </ul> Source code in <code>pyobsidian/note.py</code> <pre><code>def _get_related_notes_yaml(self: Self) -&gt; Optional[ dict[str, list[str]] ]:\n    \"\"\"Retrieves related notes from YAML content.\n\n    This function searches for related notes in the YAML content of the note.\n    It uses regular expressions to find all occurrences of related notes in the YAML content.\n    The related notes are identified by the pattern [[note|alias]], where 'note' is the name of the related note and 'alias' is an optional alias for the note.\n    The function removes the alias from the related note and returns a dictionary of the related notes, grouped by the YAML key.\n\n    Returns\n    -------\n    Optional[dict[str, list[str]]]\n        A dictionary of related notes found in the YAML content, grouped by the YAML key, or None if no related notes are found.\n    \"\"\"\n    yaml_content = self.yaml_content\n    if yaml_content is None:\n        return None\n\n    def rec_search(values, compile: re.Pattern = re.compile(r'\\[\\[(.*?)\\]\\]')) -&gt; list[str]:\n        results = []\n        if isinstance(values, str):\n            related_notes = re.findall(compile, values)\n            related_notes_without_alias = [\n                note.split('|')[0] \n                for note in related_notes\n            ]\n            results.extend(related_notes_without_alias)\n        elif isinstance(values, list):\n            for value in values:\n                results.extend(rec_search(value))\n        return results\n\n    related_notes = {}\n    for key, values in yaml_content.items():\n        related_notes[key] = rec_search(values)\n\n    valid_related_notes = {\n        key: values\n        for key, values in related_notes.items()\n        if len(values) &gt; 0\n    }\n    if len(valid_related_notes) == 0:\n        return None\n    return valid_related_notes\n</code></pre>"},{"location":"reference/note/#pyobsidian.note.NoteProperties._get_tags_inline","title":"<code>_get_tags_inline() -&gt; Optional[list[str]]</code>","text":"<p>Retrieves all the inline tags from the content of the note.</p> <p>This function uses regular expressions to find all occurrences of tags in the content of the note. The tags are identified by the pattern '#tag', where 'tag' is any non-whitespace sequence of characters.</p> <p>Returns:</p> <ul> <li> <code>Optional[list[str]]</code>           \u2013            <p>A list of tags found in the content, or None if no tags are found.</p> </li> </ul> Source code in <code>pyobsidian/note.py</code> <pre><code>def _get_tags_inline(self: Self) -&gt; Optional[list[str]]:\n    \"\"\"Retrieves all the inline tags from the content of the note.\n\n    This function uses regular expressions to find all occurrences of tags in the content of the note.\n    The tags are identified by the pattern '#tag', where 'tag' is any non-whitespace sequence of characters.\n\n    Returns\n    -------\n    Optional[list[str]]\n        A list of tags found in the content, or None if no tags are found.\n    \"\"\"\n    tags = re.compile(r'#([^\\s]+)')\n    tags_content = tags.findall(self.content)\n    if len(tags_content) == 0:\n        return None\n    return tags_content\n</code></pre>"},{"location":"reference/note/#pyobsidian.note.NoteProperties._get_tags_yaml","title":"<code>_get_tags_yaml() -&gt; Optional[list[str]]</code>","text":"<p>Retrieves the tags from the YAML content of the note.</p> <p>Returns:</p> <ul> <li> <code>Optional[list[str]]</code>           \u2013            <p>The list of tags if they exist in the YAML content,  otherwise None.</p> </li> </ul> Source code in <code>pyobsidian/note.py</code> <pre><code>def _get_tags_yaml(self: Self) -&gt; Optional[list[str]]:\n    \"\"\"Retrieves the tags from the YAML content of the note.\n\n    Returns\n    -------\n    Optional[list[str]]\n        The list of tags if they exist in the YAML content, \n        otherwise None.\n    \"\"\"\n    yaml_tags = self._get_yaml_field('tags')\n    if isinstance(yaml_tags, str):\n        yaml_tags = [yaml_tags]\n    return yaml_tags\n</code></pre>"},{"location":"reference/note/#pyobsidian.note.NoteProperties._get_yaml_field","title":"<code>_get_yaml_field(field: str) -&gt; Optional[str | list[str]]</code>","text":"<p>Retrieves the value of a specified field from the YAML content of the note.</p> <p>Parameters:</p> <ul> <li> <code>field</code>               (<code>str</code>)           \u2013            <p>The name of the field to retrieve the value of.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Optional[str | list[str]]</code>           \u2013            <p>The value of the specified field if it exists in the YAML content,  otherwise None.</p> </li> </ul> Source code in <code>pyobsidian/note.py</code> <pre><code>def _get_yaml_field(self: Self, field: str) -&gt; Optional[str | list[str]]:\n    \"\"\"Retrieves the value of a specified field from the YAML content of the note.\n\n    Parameters\n    ----------\n    field : str\n        The name of the field to retrieve the value of.\n\n    Returns\n    -------\n    Optional[str | list[str]]\n        The value of the specified field if it exists in the YAML content, \n        otherwise None.\n    \"\"\"\n    if self.yaml_content is None:\n        return None\n    field_value = self.yaml_content.get(field)\n    return field_value\n</code></pre>"},{"location":"reference/note/#pyobsidian.note.NoteReader","title":"<code>NoteReader(path: str)</code>","text":"<p>A class used to read Obsidian notes from files.</p> <p>Parameters:</p> <ul> <li> <code>path</code>               (<code>str</code>)           \u2013            <p>The path of the note file</p> </li> </ul> Source code in <code>pyobsidian/note.py</code> <pre><code>def __init__(self: Self, path: str):\n    self.__path = path\n</code></pre>"},{"location":"reference/note/#pyobsidian.note.NoteReader.path","title":"<code>path: str</code>  <code>property</code>","text":"<p>The path of the note file</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>The path of the note file</p> </li> </ul>"},{"location":"reference/note/#pyobsidian.note.NoteReader.read","title":"<code>read() -&gt; str</code>","text":"<p>Reads the content of a note from the file specified by the 'path' attribute.</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>The content of the note file</p> </li> </ul> Source code in <code>pyobsidian/note.py</code> <pre><code>def read(self: Self) -&gt; str:\n    \"\"\"Reads the content of a note from the file specified by the 'path' attribute.\n\n    Returns\n    -------\n    str\n        The content of the note file\n    \"\"\"\n    with open(self.path, 'r', encoding='utf8') as note:\n        note_content = note.read()\n    return note_content\n</code></pre>"},{"location":"reference/searchby/","title":"searchby","text":"<p>This module contains the classes that represent Obsidian search strategies.</p> <p>A search strategy define how Filter are applied to Vault.</p> <p>A generic interface for search strategies is provided by the SearchBy class.</p>"},{"location":"reference/searchby/#pyobsidian.searchby.SearchBy","title":"<code>SearchBy</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Interface for search strategies.</p>"},{"location":"reference/searchby/#pyobsidian.searchby.SearchBy.__search","title":"<code>__search(notes: list[Note], field: Field) -&gt; list[Note]</code>","text":"<p>Mechanism for the search.</p> <p>It's used by the <code>search</code> method.</p> <p>Parameters:</p> <ul> <li> <code>notes</code>               (<code>list[Note]</code>)           \u2013            <p>A list of notes to search through.</p> </li> <li> <code>field</code>               (<code>Field</code>)           \u2013            <p>The field to search for.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[Note]</code>           \u2013            <p>A list of notes that match the field value.</p> </li> </ul> Source code in <code>pyobsidian/searchby.py</code> <pre><code>def __search(self, notes: list[Note], field: Field) -&gt; list[Note]:\n    \"\"\"Mechanism for the search.\n\n    It's used by the `search` method.\n\n    Parameters\n    ----------\n    notes : list[Note]\n        A list of notes to search through.\n    field : Field\n        The field to search for.\n\n    Returns\n    -------\n    list[Note]\n        A list of notes that match the field value.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/searchby/#pyobsidian.searchby.SearchBy.condition","title":"<code>condition(note: Note, field: Field) -&gt; bool</code>","text":"<p>Function that implements the condition of the search.</p> <p>Parameters:</p> <ul> <li> <code>note</code>               (<code>Note</code>)           \u2013            <p>The note to be checked.</p> </li> <li> <code>field</code>               (<code>Field</code>)           \u2013            <p>The field to be checked.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if the condition is met, False otherwise.</p> </li> </ul> Source code in <code>pyobsidian/searchby.py</code> <pre><code>def condition(self: Self, note: Note, field: Field) -&gt; bool:\n    \"\"\"Function that implements the condition of the search.\n\n    Parameters\n    ----------\n    note : Note\n        The note to be checked.\n    field : Field\n        The field to be checked.\n\n    Returns\n    -------\n    bool\n        True if the condition is met, False otherwise.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/searchby/#pyobsidian.searchby.SearchBy.convert_field_value_to_list","title":"<code>convert_field_value_to_list(value: FieldValue) -&gt; FieldValue</code>  <code>staticmethod</code>","text":"<p>Convert the given field value to a list if it's a string.</p> <p>Parameters:</p> <ul> <li> <code>value</code>               (<code>FieldValue</code>)           \u2013            <p>The field value to be converted.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[str]</code>           \u2013            <p>A list of strings.</p> </li> </ul> Source code in <code>pyobsidian/searchby.py</code> <pre><code>@staticmethod\ndef convert_field_value_to_list(value: FieldValue) -&gt; FieldValue:\n    \"\"\"Convert the given field value to a list if it's a string.\n\n    Parameters\n    ----------\n    value : FieldValue\n        The field value to be converted.\n\n    Returns\n    -------\n    list[str]\n        A list of strings.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/searchby/#pyobsidian.searchby.SearchBy.is_valid_value","title":"<code>is_valid_value(value: FieldValue) -&gt; bool</code>","text":"<p>Check if the given value is a valid field value.</p> <p>Parameters:</p> <ul> <li> <code>value</code>               (<code>FieldValue</code>)           \u2013            <p>The value to be checked.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if the value is valid, False otherwise.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the value is not a string or a list.</p> </li> </ul> Source code in <code>pyobsidian/searchby.py</code> <pre><code>def is_valid_value(self: Self, value: FieldValue) -&gt; bool:\n    \"\"\"Check if the given value is a valid field value.\n\n    Parameters\n    ----------\n    value : FieldValue\n        The value to be checked.\n\n    Returns\n    -------\n    bool\n        True if the value is valid, False otherwise.\n\n    Raises\n    ------\n    ValueError\n        If the value is not a string or a list.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/searchby/#pyobsidian.searchby.SearchBy.search","title":"<code>search(notes: list[Note], field: Field) -&gt; list[Note]</code>","text":"<p>Search for notes that match the given field value.</p> <p>The implementation is given by the <code>__search</code> method.</p> <p>Parameters:</p> <ul> <li> <code>notes</code>               (<code>list[Note]</code>)           \u2013            <p>A list of notes to search through.</p> </li> <li> <code>field</code>               (<code>Field</code>)           \u2013            <p>The field to search for.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[Note]</code>           \u2013            <p>A list of notes that match the field value.</p> </li> </ul> Source code in <code>pyobsidian/searchby.py</code> <pre><code>def search(self: Self, notes: list[Note], field: Field,) -&gt; list[Note]:\n    \"\"\"Search for notes that match the given field value.\n\n    The implementation is given by the `__search` method.\n\n    Parameters\n    ----------\n    notes : list[Note]\n        A list of notes to search through.\n    field : Field\n        The field to search for.\n\n    Returns\n    -------\n    list[Note]\n        A list of notes that match the field value.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/searchby/#pyobsidian.searchby.SearchByContent","title":"<code>SearchByContent</code>","text":"<p>               Bases: <code>SearchByDefault</code></p> <p>Search by note properties content</p>"},{"location":"reference/searchby/#pyobsidian.searchby.SearchByDate","title":"<code>SearchByDate</code>","text":"<p>               Bases: <code>SearchByDefault</code></p> <p>Search by note properties date</p>"},{"location":"reference/searchby/#pyobsidian.searchby.SearchByDate.__search","title":"<code>__search(notes: list[Note], field: Field) -&gt; list[Note]</code>","text":"<p>Date search mechanism.</p> <p>In this mechanism, same logic as the <code>SearchByDefault</code> class is used. However, the field values \u200b\u200bare not traversed as the list is passed to the <code>condition</code>.</p> <p>A set is used to remove potential duplicates.</p> Source code in <code>pyobsidian/searchby.py</code> <pre><code>def __search(self, notes: list[Note], field: Field) -&gt; list[Note]:\n    \"\"\"Date search mechanism.\n\n    In this mechanism, same logic as the `SearchByDefault` class is used.\n    However, the field values \u200b\u200bare not traversed as the list is passed to the `condition`.\n\n    A set is used to remove potential duplicates.\n    \"\"\"\n    filtered_notes = []\n    for note in notes:\n        if self.condition(note, field):\n            filtered_notes.append(note)\n    return list(set(filtered_notes))\n</code></pre>"},{"location":"reference/searchby/#pyobsidian.searchby.SearchByDate.condition","title":"<code>condition(note: Note, field: Field) -&gt; bool</code>","text":"<p>Condition check if note date propertie is between start and end date.</p> <p>First element from field value is the date propertie. Second and third elements from field value are start and end date respectively.</p> <p>Parameters:</p> <ul> <li> <code>note</code>               (<code>Note</code>)           \u2013            <p>The note to be checked.</p> </li> <li> <code>field</code>               (<code>Field</code>)           \u2013            <p>The field to be checked.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if the note date propertie is between start and end date, False otherwise.</p> </li> </ul> Source code in <code>pyobsidian/searchby.py</code> <pre><code>def condition(self: Self, note: Note, field: Field) -&gt; bool:\n    \"\"\"Condition check if note date propertie is between start and end date.\n\n    First element from field value is the date propertie.\n    Second and third elements from field value are start and end date respectively.\n\n    Parameters\n    ----------\n    note : Note\n        The note to be checked.\n    field : Field\n        The field to be checked.\n\n    Returns\n    -------\n    bool\n        True if the note date propertie is between start and end date, False otherwise.\n    \"\"\"\n    value = field.value\n    date_propertie = value[0]\n    start_date = datetime.strptime(value[1], '%Y-%m-%d')\n    end_date = datetime.strptime(value[2], '%Y-%m-%d')\n    note_date = getattr(note.properties, date_propertie)\n    return note_date &gt;= start_date and note_date &lt;= end_date\n</code></pre>"},{"location":"reference/searchby/#pyobsidian.searchby.SearchByDate.is_valid_value","title":"<code>is_valid_value(value: FieldValue) -&gt; bool</code>","text":"<p>Check if the given value is a valid date field value.</p> <p>Parameters:</p> <ul> <li> <code>value</code>               (<code>FieldValue</code>)           \u2013            <p>The value to be checked.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if the value is valid, False otherwise.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the value is not a list with 3 elements</p> </li> </ul> Source code in <code>pyobsidian/searchby.py</code> <pre><code>def is_valid_value(self: Self, value: FieldValue) -&gt; bool:\n    \"\"\"Check if the given value is a valid date field value.\n\n    Parameters\n    ----------\n    value : FieldValue\n        The value to be checked.\n\n    Returns\n    -------\n    bool\n        True if the value is valid, False otherwise.\n\n    Raises\n    ------\n    ValueError\n        If the value is not a list with 3 elements\n    \"\"\"\n    if not isinstance(value, list):\n        raise ValueError(f'`{value}` must be a list')\n    if len(value) != 3:\n        raise ValueError(f'`{value}` must be a list with 3 elements: [\\'date_propertie\\', \\'start_date\\', \\'end_date\\']')\n    if isinstance(value, list) and len(value) == 3:\n        return True\n    raise ValueError(f'`{value}` must be a list with 3 elements: [\\'date_propertie\\', \\'start_date\\', \\'end_date\\']')\n</code></pre>"},{"location":"reference/searchby/#pyobsidian.searchby.SearchByDefault","title":"<code>SearchByDefault</code>","text":"<p>               Bases: <code>SearchBy</code></p> <p>Default search strategy. Acts as a template for other search strategies.</p>"},{"location":"reference/searchby/#pyobsidian.searchby.SearchByDefault.__search","title":"<code>__search(notes: list[Note], field: Field) -&gt; list[Note]</code>","text":"<p>Default search mechanism.</p> <p>In this mechanism, each value of the field is checked against the notes. If the value is found in the note, it is added to the filtered notes list.</p> <p>A set is used to remove potential duplicates.</p> Source code in <code>pyobsidian/searchby.py</code> <pre><code>def __search(self, notes: list[Note], field: Field) -&gt; list[Note]:\n    \"\"\"Default search mechanism.\n\n    In this mechanism, each value of the field is checked against the\n    notes. If the value is found in the note, it is added to the\n    filtered notes list.\n\n    A set is used to remove potential duplicates.\n    \"\"\"\n    values = self.convert_field_value_to_list(field.value)\n    filtered_notes = []\n    for value in values:\n        cur_field = Field(field.key, value, field.occurrence)\n        for note in notes:\n            if self.condition(note, cur_field):\n                filtered_notes.append(note)\n    return list(set(filtered_notes))\n</code></pre>"},{"location":"reference/searchby/#pyobsidian.searchby.SearchByDefault.condition","title":"<code>condition(note: Note, field: Field) -&gt; bool</code>","text":"<p>Default condition check if field value is in the note properties.</p> Source code in <code>pyobsidian/searchby.py</code> <pre><code>def condition(self: Self, note: Note, field: Field) -&gt; bool:\n    \"\"\"Default condition check if field value is in the note properties.\"\"\"\n    return field.value in getattr(note.properties, field.key)\n</code></pre>"},{"location":"reference/searchby/#pyobsidian.searchby.SearchByDefault.is_valid_value","title":"<code>is_valid_value(value: FieldValue) -&gt; bool</code>","text":"<p>Default check if a string or a list. If not, raise an error.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if the value is valid, False otherwise.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the value is not a string or a list.</p> </li> </ul> Source code in <code>pyobsidian/searchby.py</code> <pre><code>def is_valid_value(self: Self, value: FieldValue) -&gt; bool:\n    \"\"\"Default check if a string or a list. If not, raise an error.\n\n    Returns\n    -------\n    bool\n        True if the value is valid, False otherwise.\n\n    Raises\n    ------\n    ValueError\n        If the value is not a string or a list.\n    \"\"\"\n    if not isinstance(value, str) and not isinstance(value, list):\n        raise ValueError(f'`{value}` must be a string or a list')\n    return True\n</code></pre>"},{"location":"reference/searchby/#pyobsidian.searchby.SearchByFolder","title":"<code>SearchByFolder</code>","text":"<p>               Bases: <code>SearchByDefault</code></p> <p>Search by note properties folder</p>"},{"location":"reference/searchby/#pyobsidian.searchby.SearchByFolder.condition","title":"<code>condition(note: Note, field: Field) -&gt; bool</code>","text":"<p>Condition check if any value of field value is in the note properties folder.</p> Source code in <code>pyobsidian/searchby.py</code> <pre><code>def condition(self: Self, note: Note, field: Field) -&gt; bool:\n    \"\"\"Condition check if any value of field value is in the note properties folder.\"\"\"\n    norm_value = os.path.normpath(str(field.value))\n    attrs = getattr(note.properties, field.key)\n    return any([norm_value in attr for attr in attrs])\n</code></pre>"},{"location":"reference/searchby/#pyobsidian.searchby.SearchByOccurrence","title":"<code>SearchByOccurrence</code>","text":"<p>               Bases: <code>SearchByDefault</code></p> <p>Occurrence search strategy.</p> <p>Acts as a template for search strategies that need to check if the field value is in the note properties that occurs inline, yaml or both.</p>"},{"location":"reference/searchby/#pyobsidian.searchby.SearchByOccurrence.condition","title":"<code>condition(note: Note, field: Field) -&gt; bool</code>","text":"<p>Condition check if any value of field value is in the note properties that occurs inline, yaml or both.</p> <p>Use the same <code>search</code> method as the <code>SearchByDefault</code> class.</p> Source code in <code>pyobsidian/searchby.py</code> <pre><code>def condition(self: Self, note: Note, field: Field) -&gt; bool:\n    \"\"\"Condition check if any value of field value is in the note properties that occurs inline, yaml or both.\n\n    Use the same `search` method as the `SearchByDefault` class.\n    \"\"\"\n    inline = getattr(note.properties, field.key)['inline']\n    yaml = getattr(note.properties, field.key)['yaml']\n    check_inline = field.value in inline if inline else False\n    check_yaml = field.value in yaml if yaml else False\n    match field.occurrence:\n        case 'inline':\n            return check_inline\n        case 'yaml':\n            return check_yaml\n        case 'file':\n            return check_inline or check_yaml\n        case _:\n            raise ValueError(f'`{field.occurrence}` is not a valid tag occurrence')\n</code></pre>"},{"location":"reference/searchby/#pyobsidian.searchby.SearchByRegex","title":"<code>SearchByRegex</code>","text":"<p>               Bases: <code>SearchByDefault</code></p> <p>Search by regex in note properties content</p>"},{"location":"reference/searchby/#pyobsidian.searchby.SearchByRegex.condition","title":"<code>condition(note: Note, field: Field) -&gt; bool</code>","text":"<p>Condition check regex pattern matches in note properties content.</p> Source code in <code>pyobsidian/searchby.py</code> <pre><code>def condition(self: Self, note: Note, field: Field) -&gt; bool:\n    \"\"\"Condition check regex pattern matches in note properties content.\"\"\"\n    attr = getattr(note.properties, 'content')\n    return any(re.findall(str(field.value), attr))\n</code></pre>"},{"location":"reference/searchby/#pyobsidian.searchby.SearchByTag","title":"<code>SearchByTag</code>","text":"<p>               Bases: <code>SearchByOccurrence</code></p> <p>Search by note properties tag inline, yaml or both</p>"},{"location":"reference/searchby/#pyobsidian.searchby.get_search_strategies","title":"<code>get_search_strategies() -&gt; dict[FieldKey, SearchBy]</code>","text":"<p>Define a dict of search strategies</p> <p>Returns:</p> <ul> <li> <code>dict[FieldKey, SearchBy]</code>           \u2013            <p>The dict of search strategies</p> </li> </ul> Source code in <code>pyobsidian/searchby.py</code> <pre><code>def get_search_strategies() -&gt; dict[FieldKey, SearchBy]:\n    \"\"\"Define a dict of search strategies\n\n    Returns\n    -------\n    dict[FieldKey, SearchBy]\n        The dict of search strategies\n    \"\"\"\n    return {\n        'folder': SearchByFolder(),\n        'content': SearchByContent(),\n        'regex': SearchByRegex(),\n        'date': SearchByDate(),\n        'tag': SearchByTag(),\n        'related_note': SearchByRelatedNote()\n    }\n</code></pre>"},{"location":"reference/vault/","title":"vault","text":"<p>This module contains the classes that represent Obsidian vaults.</p> <p>A vault is a collection of notes that can be searched through.</p>"},{"location":"reference/vault/#pyobsidian.vault.Vault","title":"<code>Vault(path: str, notes: list[Note] = [], filter: Filter = Filter())</code>","text":"<p>A class that represents an Obsidian vault.</p> <p>Parameters:</p> <ul> <li> <code>path</code>               (<code>str</code>)           \u2013            <p>The path of the vault.</p> </li> <li> <code>notes</code>               (<code>list[Note]</code>, default:                   <code>[]</code> )           \u2013            <p>The list of notes in the vault</p> </li> <li> <code>filter</code>               (<code>Filter</code>, default:                   <code>Filter()</code> )           \u2013            <p>The filter applied to the vault</p> </li> </ul> Source code in <code>pyobsidian/vault.py</code> <pre><code>def __init__(\n    self: Self,\n    path: str,\n    notes: list[Note] = [],\n    filter: Filter = Filter()\n) -&gt; None:\n    self.__path = path\n    self.__notes = notes\n    self.__filter = filter\n</code></pre>"},{"location":"reference/vault/#pyobsidian.vault.Vault.filter","title":"<code>filter: Filter</code>  <code>property</code>","text":"<p>The filter applied to the vault</p> <p>Returns:</p> <ul> <li> <code>Filter</code>           \u2013            <p>The filter applied to the vault</p> </li> </ul>"},{"location":"reference/vault/#pyobsidian.vault.Vault.notes","title":"<code>notes: list[Note]</code>  <code>property</code>","text":"<p>The list of notes in the vault</p> <p>Returns:</p> <ul> <li> <code>list[Note]</code>           \u2013            <p>The list of notes in the vault</p> </li> </ul>"},{"location":"reference/vault/#pyobsidian.vault.Vault.path","title":"<code>path: str</code>  <code>property</code>","text":"<p>The path of the vault</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>The path of the vault</p> </li> </ul>"},{"location":"reference/vault/#pyobsidian.vault.Vault.search_strategies","title":"<code>search_strategies: dict[FieldKey, SearchBy]</code>  <code>property</code>","text":"<p>The search strategies used by the vault</p> <p>Returns:</p> <ul> <li> <code>dict[FieldKey, SearchBy]</code>           \u2013            <p>The search strategies used by the vault</p> </li> </ul>"},{"location":"reference/vault/#pyobsidian.vault.Vault.__search","title":"<code>__search(notes: list[Note], field: Field) -&gt; list[Note]</code>","text":"<p>A function that searches for notes based on a given field using a specific search strategy.</p> <p>Parameters:</p> <ul> <li> <code>notes</code>               (<code>list[Note]</code>)           \u2013            <p>A list of notes to search through.</p> </li> <li> <code>field</code>               (<code>Field</code>)           \u2013            <p>The field to search for.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[Note]</code>           \u2013            <p>A list of notes that match the search criteria.</p> </li> </ul> Source code in <code>pyobsidian/vault.py</code> <pre><code>def __search(\n    self,\n    notes: list[Note], \n    field: Field\n) -&gt; list[Note]:\n    \"\"\"A function that searches for notes based on a given field using a specific search strategy.\n\n    Parameters\n    ----------\n    notes : list[Note]\n        A list of notes to search through.\n    field : Field\n        The field to search for.\n\n    Returns\n    -------\n    list[Note]\n        A list of notes that match the search criteria.\n    \"\"\"\n    search_strategy = self.search_strategies[field.key]\n    notes = search_strategy.search(notes, field)\n    return notes\n</code></pre>"},{"location":"reference/vault/#pyobsidian.vault.Vault.add_new_search_strategy","title":"<code>add_new_search_strategy(name: FieldKey, strategy: SearchBy) -&gt; dict[FieldKey, SearchBy]</code>  <code>classmethod</code>","text":"<p>Adds a new search strategy to Vault class.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>FieldKey</code>)           \u2013            <p>The name of the new search strategy.</p> </li> <li> <code>strategy</code>               (<code>SearchBy</code>)           \u2013            <p>The search strategy to be added.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[FieldKey, SearchBy]</code>           \u2013            <p>The updated search strategies.</p> </li> </ul> Source code in <code>pyobsidian/vault.py</code> <pre><code>@classmethod\ndef add_new_search_strategy(\n    cls: type[Self],\n    name: FieldKey,\n    strategy: SearchBy\n) -&gt; dict[FieldKey, SearchBy]:\n    \"\"\"Adds a new search strategy to Vault class.\n\n    Parameters\n    ----------\n    name : FieldKey\n        The name of the new search strategy.\n    strategy : SearchBy\n        The search strategy to be added.\n\n    Returns\n    -------\n    dict[FieldKey, SearchBy]\n        The updated search strategies.\n    \"\"\"\n    cls.__search_strategies[name] = strategy\n    new_strategy = cls.__search_strategies\n    return new_strategy\n</code></pre>"},{"location":"reference/vault/#pyobsidian.vault.Vault.execute","title":"<code>execute() -&gt; Vault</code>","text":"<p>This method applies the filter to the current Vault object.</p> <p>Returns:</p> <ul> <li> <code>Vault</code>           \u2013            <p>A new Vault object with the filter applied.</p> </li> </ul> Source code in <code>pyobsidian/vault.py</code> <pre><code>def execute(self: Self) -&gt; Vault:        \n    \"\"\"This method applies the filter to the current Vault object.\n\n    Returns\n    -------\n    Vault\n        A new Vault object with the filter applied.\n    \"\"\"\n    filter = self.filter\n    if not filter:\n        return self\n    notes = self.notes\n    if not notes:\n        notes = self.get_notes()\n\n    filtered_notes = notes\n    new_notes: list[Note] = []\n    for f_field in filter:\n        mode = f_field.mode\n        if mode == 'and':\n            new_notes = self.__search(new_notes or filtered_notes, f_field.field)\n        elif mode == 'or':\n            new_notes.extend(self.__search(notes, f_field.field))\n        else:\n            raise ValueError(f'`{mode}` is not a valid mode. Must be `and` or `or`')\n    unique_new_notes = list(set(new_notes))\n    new_vault = Vault(path=self.path, notes=unique_new_notes, filter=filter)\n    return new_vault\n</code></pre>"},{"location":"reference/vault/#pyobsidian.vault.Vault.find_by","title":"<code>find_by(by: FieldKey, value: FieldValue, occurrence: FieldOcurrence = 'file', mode: FilterMode = 'and') -&gt; Vault</code>","text":"<p>Add a new filter field to current filter.</p> <p><code>by</code>, <code>value</code> and <code>occurrence</code> build the field to search for. mode is used to specify how the filter should be applied. If mode is 'and' (default) the filter will be applied in current vault notes. If mode is 'or' the filter will be applied in all vault notes. This can be used to create complex filters. The sequence of the filter fields will be preserved.</p> <p>For example vault.find_by('folder', 'folder1').find_by('folder', 'folder2'). In this case, the filter will be applied to search for notes in folder1. After that, the filter will be applied in notes that are returned by first filter, returning notes in folder2. This example is equivalent to finding notes that are in 'folder2' which is a subfolder of 'folder1'. </p> <p>If mode is 'or' the filter will be applied to search for notes in folder1 or folder2.</p> <p>Parameters:</p> <ul> <li> <code>by</code>               (<code>FieldKey</code>)           \u2013            <p>The field to search by.</p> </li> <li> <code>value</code>               (<code>FieldValue</code>)           \u2013            <p>The value to search for.</p> </li> <li> <code>occurrence</code>               (<code>FieldOcurrence</code>, default:                   <code>'file'</code> )           \u2013            <p>The occurrence of the value to search for. Defaults to 'file'.</p> </li> <li> <code>mode</code>               (<code>FilterMode</code>, default:                   <code>'and'</code> )           \u2013            <p>The mode of the filter. Defaults to 'and'.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Vault</code>           \u2013            <p>A new Vault object with the new filter field added.</p> </li> </ul> Source code in <code>pyobsidian/vault.py</code> <pre><code>def find_by(\n    self: Self, \n    by: FieldKey, \n    value: FieldValue,\n    occurrence: FieldOcurrence = 'file',\n    mode: FilterMode='and'\n) -&gt; Vault:\n    \"\"\"Add a new filter field to current filter.\n\n    `by`, `value` and `occurrence` build the field to search for.\n    mode is used to specify how the filter should be applied.\n    If mode is 'and' (default) the filter will be applied in current vault notes.\n    If mode is 'or' the filter will be applied in all vault notes.\n    This can be used to create complex filters.\n    The sequence of the filter fields will be preserved.\n\n    For example vault.find_by('folder', 'folder1').find_by('folder', 'folder2').\n    In this case, the filter will be applied to search for notes in folder1.\n    After that, the filter will be applied in notes that are returned by first filter, returning notes in folder2.\n    This example is equivalent to finding notes that are in 'folder2' which is a subfolder of 'folder1'. \n\n    If mode is 'or' the filter will be applied to search for notes in folder1 or folder2.\n\n    Parameters\n    ----------\n    by : FieldKey\n        The field to search by.\n    value : FieldValue\n        The value to search for.\n    occurrence : FieldOcurrence, optional\n        The occurrence of the value to search for. Defaults to 'file'.\n    mode : FilterMode, optional\n        The mode of the filter. Defaults to 'and'.\n\n    Returns\n    -------\n    Vault\n        A new Vault object with the new filter field added.\n    \"\"\"\n    field = Field(by, value, occurrence)\n    filter_field = FilterField(field, mode)\n    cur_filter = self.filter\n    new_filter = cur_filter.add_field(filter_field)\n    new_vault = Vault(path=self.path, notes=self.notes, filter=new_filter)\n    return new_vault\n</code></pre>"},{"location":"reference/vault/#pyobsidian.vault.Vault.get_notes","title":"<code>get_notes(extension: str = '.md') -&gt; list[Note]</code>","text":"<p>Retrieves a list of notes from the specified vault directory.</p> <p>Parameters:</p> <ul> <li> <code>extension</code>               (<code>str</code>, default:                   <code>'.md'</code> )           \u2013            <p>The file extension to filter the notes by. Defaults to '.md'.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[Note]</code>           \u2013            <p>A list of Note objects representing the notes found in the vault directory.</p> </li> </ul> Source code in <code>pyobsidian/vault.py</code> <pre><code>def get_notes(self: Self, extension: str='.md') -&gt; list[Note]:\n    \"\"\"Retrieves a list of notes from the specified vault directory.\n\n    Parameters\n    ----------\n    extension : str, optional\n        The file extension to filter the notes by. Defaults to '.md'.\n\n    Returns\n    -------\n    list[Note]\n        A list of Note objects representing the notes found in the vault directory.\n    \"\"\"\n    root = self.path\n    notes = []\n    for root, _, filenames in os.walk(root):\n        for filename in filenames:\n            if filename.endswith(extension):\n                note_path = os.path.join(root, filename)\n                notes.append(Note(note_path))\n    return notes\n</code></pre>"}]}